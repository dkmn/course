<?php

/**
 * @file
 * Core functionality for Courses.
 *
 */
// Load built-in LMS.
require_once dirname(__FILE__) . '/includes/course.drupal.inc';

// Course Outline functions
require_once dirname(__FILE__) . '/includes/course.outline.inc';

/**
 * Implementation of hook_menu().
 */
function course_menu() {
  $items = array();

  // Main configuration.
  $items['admin/settings/course'] = array(
    'title' => 'Course',
    'description' => 'Configure courses.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_admin_settings'),
    'access arguments' => array('administer course'),
  );

  // Default tab for LMS.
  $items['admin/settings/course/lms'] = array(
    'title' => 'LMS',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  // Configure per-course user types.
  $items['admin/settings/course/user-types'] = array(
    'title' => 'User types',
    'description' => 'Configure course user types.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_user_type_settings_form'),
    'access arguments' => array('administer course'),
    'type' => MENU_LOCAL_TASK,
  );

  // Run install tasks for an LMS.
  $items['admin/settings/course/%/install'] = array(
    'title' => 'Install external application',
    'access callback' => true,
    'page callback' => '_course_lms_install',
    'page arguments' => array(3),
  );

  // Run post-install tasks for an LMS.
  $items['admin/settings/course/%/postinstall'] = array(
    'title' => 'Perform post installation tasks',
    'access callback' => true,
    'page callback' => '_course_lms_postinstall',
    'page arguments' => array(3),
    'type' => MENU_CALLBACK,
  );

  // Configure an LMS.
  $items['admin/settings/course/%course_lms/configure'] = array(
    'title' => 'Configure',
    'description' => 'Configure courses.',
    'page callback' => 'course_configure',
    'page arguments' => array(3),
    'access arguments' => array('administer course'),
  );

  // Per course user type selection.
  $items['node/%course/course-user-type'] = array(
    'title' => 'Choose user type',
    'description' => 'Allow the learner to choose their user type.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_user_type_form', 1),
    'access callback' => 'user_is_logged_in',
    'type' => MENU_CALLBACK,
  );

  // Landing page for course completion.
  $items['node/%course/course-outline'] = array(
    'title' => 'Course outline',
    'access arguments' => array('edit courses'),
    'page arguments' => array('course_outline_overview_form'),
    'page callback' => 'drupal_get_form',
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/course.outline.inc',
  );

  // Landing page for course completion.
  $items['node/%course/course-complete'] = array(
    'title' => 'Course completion',
    'access callback' => TRUE,
    'page arguments' => array(1),
    'page callback' => 'course_outline_show_complete_links',
    'type' => MENU_CALLBACK,
    'file' => 'includes/course.outline.inc',
  );


  // Display the 'Take course' menu item as a tab or link, depending.
  $items['node/%course/takecourse'] = array(
    'title' => 'Take course',
    'title callback' => 'course_takecourse_title',
    'title arguments' => array(1),
    'description' => 'Take course.',
    'page callback' => 'course_take_course',
    'page arguments' => array(1),
    'access callback' => 'course_take_course_menu_access',
    'access arguments' => array(1),
    'type' => variable_get('course_takecourse_tab_display', 1) ? MENU_LOCAL_TASK : MENU_CALLBACK,
  );

  // Display the 'Course settings' menu item as a tab or link, depending.
  $items['node/%course/coursesettings'] = array(
    'title' => 'Course settings',
    'description' => 'Course settings.',
    'page callback' => 'course_edit_course',
    'page arguments' => array(1),
    'access callback' => 'course_settings_menu_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );

  // Reports page listing each course object.
  $items['node/%course/course-reports/objects'] = array(
    'title' => 'Course objects',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'course_object_reports_page',
    'page arguments' => array(1),
    'access arguments' => array('access course reports'),
    'file' => 'includes/course.reports.inc',
  );

  // Global report area
  $items['admin/reports/course'] = array(
    'title' => 'Course reports',
    'description' => 'View and download course information.',
    'access arguments' => array('access all course reports'),
    'page callback' => 'system_admin_menu_block_page',
    'file path' => drupal_get_path('module', 'system'),
    'file' => 'system.admin.inc',
  );

  // Course object
  $items['node/%course/course-object/%course_object'] = array(
    'title' => 'Course object router',
    'page callback' => 'course_object_take',
    'page arguments' => array(3),
    'access callback' => TRUE,
  );

  // Course object edit
  $items['node/%course/course-object/%ctools_js/%course_object/edit'] = array(
    'title' => 'Course object settings',
    'page callback' => 'course_object_edit',
    'page arguments' => array(1, 3, 4),
    'access callback' => TRUE,
  );

  // Course object settings link
  $items['node/%course/course-object/%ctools_js/store/%'] = array(
    'page callback' => 'course_store_temp_object',
    'page arguments' => array(1, 3, 5, 6),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // AHAH handler.
  $items['node/%course/course-outline/%ctools_js/more/%'] = array(
    'page callback' => 'course_outline_overview_js_more',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'page arguments' => array(1, 3, 5),
  );

  return $items;
}

/**
 * When a user selects a new requirement_component, update it in the database so
 * our modals etc use the right course object.
 *
 * @param type $node
 * @param type $js
 * @param type $uniqid
 */
function course_store_temp_object($node, $js, $uniqid) {
  if ($js) {
    $nid = $node->nid;
    $changed = explode('-', $_POST['ctools_changed']);
    $_SESSION['course'][$nid]['editing'][$uniqid]['requirement_type'] = $changed[0];
    $_SESSION['course'][$nid]['editing'][$uniqid]['requirement_component'] = $changed[1];
    ctools_include('ajax');
    $output = array();
    ctools_ajax_render($output);
  }
  else {
    exit;
  }
}

/**
 * Callback for modal window/nojs.
 */
function course_object_edit($node, $js, $courseObject) {
  if ($js) {
    ctools_include('ajax');
    ctools_include('modal');
    $form_state = array(
      'ajax' => TRUE,
      'title' => t("Settings for %t", array('%t' => $courseObject->getTitle())),
    );

    $form_state['args'][] = $courseObject;

    $output = ctools_modal_form_wrapper('course_object_edit_form', $form_state, $courseObject);
    if (empty($output)) {
      $output[] = ctools_modal_command_loading();
      $output[] = ctools_modal_command_dismiss();
    }
    ctools_ajax_render($output);
  }
  else {
    return drupal_get_form('course_object_edit_form', $courseObject);
  }
}

/**
 * Return the course object's edit form.
 */
function course_object_edit_form(&$form_state, $courseObject) {
  return $courseObject->optionsForm($form, $form_state);
}

function course_object_edit_form_submit(&$form, &$form_state) {
  if ($form_state['values']['uniqid']) {
    $nid = $form_state['values']['nid'];
    $record = $_SESSION['course'][$nid]['editing'][$form_state['values']['uniqid']];
    $courseObject = course_get_course_object($record);
    $courseObject->setCourseNid($nid);
    $courseObject->setId($form_state['values']['uniqid']);
    $courseObject->optionsSubmit($form, $form_state);
  }
}

/**
 * Load a course object from session cache or database.
 */
function course_object_load($snid) {
  global $user;
  $nid = arg(0) == 'node' && is_numeric(arg(1)) ? arg(1) : 0;
  if (!is_numeric($snid)) {
    $courseObject = course_get_course_object($_SESSION['course'][$nid]['editing'][$snid]['requirement_type'], $_SESSION['course'][$nid]['editing'][$snid]['requirement_component']);
    $courseObject->setId($snid);
    $courseObject->setCourseNid($nid);
  }
  else {
    $courseObject = course_get_course_object($snid, NULL, NULL, $user);
  }
  return $courseObject;
}

/**
 * Take the course object.
 */
function course_object_take($courseObject) {
  drupal_set_title($courseObject->getTitle());
  return $courseObject->takeCourseObject();
}

/**
 * Implementation of hook_menu_alter().
 *
 * Look at a variable to determine the default course report. Did this to avoid
 * any one module having to define itself as a default local task.
 */
function course_menu_alter(&$items) {
  $default = variable_get('course_reports_default_report', 'node/%/course-reports/overview');

  if ($default) {
    $parent = $items[$default];
    $items[$default]['type'] = MENU_DEFAULT_LOCAL_TASK;
    $items[$default]['weight'] = -999;
    $parent['type'] = MENU_LOCAL_TASK;
    $parent['title'] = 'Course reports';
    $parent['access arguments'] = array('access course reports');
    $items['node/%course/course-reports'] = $parent;
  }
}

/**
 * Implements hook_block().
 */
function course_block($op = 'list', $delta = 0) {
  switch ($op) {
    case 'list':
      $info = array(
        'outline' => array('info' => t('Course: Outline'), 'cache' => BLOCK_NO_CACHE),
        'navigation' => array('info' => t('Course: Navigation'), 'cache' => BLOCK_NO_CACHE),
      );
      return $info;
    case 'view':
      module_load_include('inc', 'course', 'includes/course.block');
      $function = "_course_block_{$delta}";
      if (function_exists($function)) {
        return call_user_func($function);
      }
      break;
  }
}

/**
 * Menu title handler for the Take course tab.
 *
 * @return string
 *   "Review course" or "Take course", depending on the current user's
 *   completion status.
 */
function course_takecourse_title($node) {
  global $user;
  $report = course_report_load($node, $user);
  return ($user->uid > 1 && $report->complete) ? t('Review course') : t('Take course');
}

/**
 * Menu loader: check if node is a Course.
 */
function course_load($arg) {
  $node = node_load($arg);
  return course_node_is_course($node) ? $node : FALSE;
}

/**
 * Menu loader: load learning app.
 */
function course_lms_load($arg) {
  return course_get_lms($arg);
}

/**
 * Fire the submodule's postinstall implementation.
 */
function _course_lms_postinstall($key) {
  $lapp = course_get_lms($key);
  module_invoke($lapp['module'], 'lms_postinstall', $key);
  drupal_set_message(t('Post installation tasks for %lapp complete.', array('%lapp' => $lapp['name'])));
  drupal_goto('admin/settings/course');
}

/**
 * Fire the submodule's install implementation.
 */
function _course_lms_install($key) {
  $lapp = course_get_lms($key);
  if (!empty($lapp['install url'])) {
    // If the installer URL is set then this is an external application.
    $post = '';
    $post .= '<h2>When you are finished installing, be sure to ' . l('run the post installation tasks', "admin/settings/course/$key/postinstall") . '.</h2>';
    $post .= '<br/>';
    return $post . course_iframe($lapp['install url']);
  }
  else {
    // No installer URL, this is Drupal-based.
    $out = module_invoke($lapp['module'], 'lms_install', $key);
    if (module_invoke($lapp['module'], 'lms_status', $key)) {
      $post = '<h2>Please ' . l('run the post installation tasks', "admin/settings/course/$key/postinstall") . '.</h2>';
    }
    else {
      $post = '<h2>Installation failed...' . l('try again?', "admin/settings/course/$key/install") . '</h2>';
    }
    return $out . $post;
  }
}

/**
 * Implementation of hook_perm().
 *
 * Define permissions to take courses and edit course settings.
 */
function course_perm() {
  return array(
    // Manage course settings
    'administer course',
    // Take courses
    'access course',
    // Edit course objects (not the node itself)
    'edit courses',
    // Can user get to the course reports area
    'access course reports',
    // Can use view all course reports
    'access all course reports',
  );
}

/**
 * Should the take course button show on this node?
 *
 * This differs from course_take_course_access as it only returns true/false.
 */
function course_take_course_menu_access($node) {
  global $user;
  static $courses = array();

  if (!isset($courses[$node->nid])) {
    $hooks = module_invoke_all('course_has_takecourse', $node, $user);
    $courses[$node->nid] = !in_array(FALSE, $hooks);
  }

  return $courses[$node->nid];
}

/**
 * Should the course settings tab show on this node?
 *
 * This differs from course_take_course_access as it only returns true/false. If a module's
 */
function course_settings_menu_access($node) {
  global $user;
  static $courses = array();

  if (!isset($courses[$node->nid])) {
    $hooks = module_invoke_all('course_has_settings', $node, $user);
    $courses[$node->nid] = !in_array(FALSE, $hooks) && course_settings_access($node);
  }

  return $courses[$node->nid];
}

/**
 * Determine if taking this course should be restricted.
 *
 * If any module implementing hook_can_take_course() returns FALSE or an array
 * containing 'success' => FALSE, the course will be restricted.
 *
 * @see course_can_take_course() and hook_can_take_course() for an example of
 * how to use this hook.
 *
 * @param object $node The course node.
 * @return array
 *   An array of 'success' and 'message'.
 */
function course_take_course_access(&$node) {
  global $user;
  static $courses = array();

  // Don't let anonymous users see /takecourse. Also keeps from being indexed.
  if (arg(2) == 'takecourse' && !user_is_logged_in() && $_SERVER['SCRIPT_NAME'] != '/cron.php') {
    drupal_set_message(t('You must login or register before taking this course.'));
    // Remove desination temporarily.
    // @todo find out why this causes an infinite loop on sites with existing drupal_goto()
    // in $items['user/login']['page callback'] via hook_menu_alter().
    // Does this todo still apply?
    drupal_goto('user/login', drupal_get_destination());
  }

  if (!isset($courses[$node->nid])) {
    $courses[$node->nid]['success'] = TRUE;
    $hooks = module_invoke_all('can_take_course', $node, $user);
    foreach ($hooks as $key => $hook) {
      if (!$hook) {
        // Ok. Old style blocker. But look for messages.
        $courses[$node->nid] = FALSE;
      }
      if (is_array($hook) && !$hook['success']) {
        // New style blocker, return immediately.
        $courses[$node->nid] = $hook;
        return $hook;
      }
    }
  }

  if (is_array($courses[$node->nid])) {
    return $courses[$node->nid];
  }
  else {
    return array(
      'success' => $courses[$node->nid],
      'message' => "Old style blocker",
    );
  }
}

/**
 * Callback for checking course settings permission.
 */
function course_settings_access($node) {
  global $user;
  return ((user_access('edit own course products') || user_access('edit own course content')) && $node->uid == $user->uid) || user_access('edit courses');
}

/**
 * Implementation of hook_can_take_course().
 *
 * Check for built-in access restrictions (enrollment, release/expiration).
 *
 * @param object $node The course node.
 * @param object $user The user to check.
 */
function course_can_take_course($node, $user) {
  if (variable_get('course_access_restrict_enrol', 0) && !course_enrolment_check($node, $user)) {
    if (!(variable_get('course_access_bypass_checkout', 1) && empty($node->sell_price))) {
      return array(array(
          'success' => FALSE,
          'message' => 'Sorry, you are not yet enrolled in this course.',
        ));
    }
  }

  $sql = "select * from {course_enrolment} where nid = %d and uid = %d";
  if ($row = db_fetch_object(db_query($sql, $node->nid, $user->uid))) {
    if ($node->course['duration'] > 0 && time() > $row->enrol_end) {
      return array(array(
          'success' => FALSE,
          'message' => 'Sorry, your enrollment has expired for this course.',
        ));
    }
  }

  if ($node->course['closed']) {
    if ($node->course['type'] == 'enduring' && time() > strtotime($node->course['close'])) {
      return array(array(
          'success' => FALSE,
          'message' => 'Sorry, this course is expired.',
        ));
    }
  }
}

/**
 * Define the Course settings form.
 */
function course_admin_settings() {
  $lapps = course_available_lms();

  $form['installation'] = array(
    '#type' => 'fieldset',
    '#title' => 'Available LMS backends',
  );

  foreach ($lapps as $key => &$lapp) {
    $links = array();
    if (module_invoke($lapp['module'], 'lms_status', $key)) {
      $lapp['status'] = 'Installed.';
      $links['postinstall'] = array(
        'title' => 'Post-install',
        'href' => "admin/settings/course/$key/postinstall",
      );

      $links['configure'] = array(
        'title' => 'Configure',
        'href' => "admin/settings/course/$key/configure",
      );
    }
    else {
      $lapp['status'] = 'Not installed.';
      $links['install'] = array(
        'title' => 'Install',
        'href' => "admin/settings/course/$key/install",
      );
    }

    unset($lapp['machine']);
    unset($lapp['install url']);
    unset($lapp['module']);
    unset($lapp['weight']);
    $lapp['action'] = theme_links($links);
  }

  $header = array('Name', 'Description', 'Status', 'Action');
  $form['installation']['#value'] = theme_table($header, $lapps);

  $form['course_take_course_button_show'] = array(
    '#title' => 'Show take course button on',
    '#type' => 'checkboxes',
    '#options' => array(
      'teaser' => 'Teaser',
      'page' => 'Page',
    ),
    '#default_value' => variable_get('course_take_course_button_show', array()),
    '#description' => 'Check to show the take course button on courses.',
  );

  $form['course_disable_builtin_lms'] = array(
    '#title' => 'Disable built-in LMS',
    '#type' => 'checkbox',
    '#default_value' => variable_get('course_disable_builtin_lms', 0),
    '#description' => 'Disables the built-in LMS using Drupal learning objects.',
  );

  $form['course_disable_regions'] = array(
    '#title' => 'Disable theme regions when taking a course',
    '#type' => 'checkboxes',
    '#default_value' => variable_get('course_disable_regions', array()),
    '#options' => system_region_list(variable_get('theme_default', '')),
  );

  $form['course_takecourse_tab_display'] = array(
    '#title' => 'Show a "take course" tab on course nodes',
    '#type' => 'checkbox',
    '#default_value' => variable_get('course_takecourse_tab_display', 1),
  );

  $form['course_access_restrict_enrol'] = array(
    '#title' => 'User must be enrolled to take course',
    '#description' => 'Restricts taking courses to users who have been enrolled in the course by external methods (e.g. Ubercart "Enroll User" conditional action). If this is not checked, users will be automatically enrolled when they click Take Course. This box should be checked if courses are products.',
    '#type' => 'checkbox',
    '#default_value' => variable_get('course_access_restrict_enrol', 0),
  );

  $form['course_access_bypass_checkout'] = array(
    '#title' => 'Bypass checkout for free courses',
    '#description' => "If course is free, user may bypass checkout and be automatically enrolled in the course.",
    '#type' => 'checkbox',
    '#default_value' => variable_get('course_access_bypass_checkout', 1),
  );

  $form['course_object_custom_fields'] = array(
    '#title' => 'Custom course object fields',
    '#type' => 'textarea',
    '#rows' => 5,
    '#description' => 'Enter a key|value format to enable custom fields on course objects.',
    '#default_value' => variable_get('course_object_custom_fields', ''),
    '#element_validate' => array('course_check_keyval'),
  );

  return system_settings_form($form);
}

/**
 * Element validator to make sure all entries are in key|val format.
 */
function course_check_keyval($element, &$form_state) {
  $val = trim($element['#value']);
  if ($val) {
    if (substr_count($val, "\n") + 1 != substr_count($val, '|')) {
      form_error($element, 'Please ensure all custom object fields are in the format key|value.');
    }
  }
}

/**
 * Get an array of custom course object fields.
 *
 * @return array
 *   An array of custom course object fields, in the format key => value.
 */
function course_object_custom_fields() {
  $fields = array();

  $list = explode("\n", variable_get('course_object_custom_fields', ''));
  $list = array_map('trim', $list);
  $list = array_filter($list, 'strlen');
  foreach ($list as $opt) {
    // Sanitize the user input with a permissive filter.
    $opt = content_filter_xss($opt);
    if (strpos($opt, '|') !== FALSE) {
      list($key, $value) = explode('|', $opt);
      $fields[$key] = (isset($value) && $value !== '') ? $value : $key;
    }
    else {
      $fields[$key] = $opt;
    }
  }

  return $fields;
}

/**
 * Implementation of hook_nodeapi().
 *
 * When a course is saved, handles changes to the course outline and the
 * creation of external courses.
 *
 * Renders the "take course" button on view.
 */
function course_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  if (course_node_is_course($node)) {
    switch ($op) {
      case 'prepare':
        if (count(course_available_lms()) == 0) {
          drupal_set_message("You haven't installed an LMS yet. Please visit " . l('course configuration', 'admin/settings/course') . '.', 'error');
        }
        break;
      case 'validate':
        $lapp = course_get_lms($node->course['lms']);
        $status = module_invoke($lapp['module'], 'lms_status', $node->course['lms']);
        if ($status) {
          // Validated OK! LMS module was installed
        }
        else {
          $message = t("LMS (%application) not yet set up.", array('%application' => $lapp['name']));
          $message .= " Please " . l('configure the Course module', 'admin/settings/course') . '.';
          form_set_error('', $message);
        }
        break;
      case 'view':
        // Render take course button.
        $show = variable_get('course_take_course_button_show', array());
        if (($teaser && $show['teaser']) || ($page && $show['page'])) {
          $node->content['course']['#value'] = course_render_button($node);
        }
        break;
      case 'insert':
      case 'update':
        $record = $node->course;
        $record['nid'] = $node->nid;
        unset($record['open']);
        unset($record['close']);
        $lapp = course_get_lms($node->course['lms']);
        // Invoke modules for creation of an external course.
        $response = module_invoke($lapp['module'], 'course_create_external', $node);
        if ($response) {
          $record['cid'] = $response;
        }
        $existing = db_result(db_query('select 1 from {course_node} where nid = %d', $node->nid));
        if ($existing) {
          // Don't save LMS. Cannot be changed currently.
          unset($record['lms']);
          drupal_write_record('course_node', $record, array('nid'));
        }
        else {
          drupal_write_record('course_node', $record);
        }
        // Let other course modules know about the recently created course.
        $node->course['cid'] = $record['cid'];
        //course_outline_overview_save($node, $op);
        module_invoke_all('course_nodeapi_extra', $node, $op);
        break;
      case 'load':
        if ($course = db_fetch_array(db_query('select * from {course_node} where nid = %d', $node->nid))) {
          // Attach additional module provided info to $node->course.
          $hooks = module_invoke_all('course_nodeapi_extra', $node, 'load');
          $load['course'] = array_merge($course, $hooks);
        }

        // Load the course outline to the node.
        $sql = "SELECT * FROM {course_outline}
          WHERE nid = %d
          ORDER BY weight ASC";
        $result = db_query($sql, $node->nid);
        while ($requirement = db_fetch_object($result)) {
          foreach ($requirement as $key => $value) {
            $rarray[$requirement->snid]->$key = $value;
          }
        }

        $load['course_outline'] = array('requirements' => $rarray);
        return $load;
        break;
      case 'delete':
        // Clean up course specific settings and enrollments when a course is
        // deleted.
        db_query("DELETE FROM {course_node} where nid = %d", $node->nid);
        db_query("DELETE FROM {course_enrolment} where nid = %d", $node->nid);
        break;
    }
  }
}

/**
 * Check the permissions of showing the take course button, and return the HTML.
 */
function course_render_button($node) {
  $result = course_enrol_access($node);
  if ($result['success']) {
    $result = course_take_course_access($node);
  }
  // Allow another module to force the take course button to show.
  drupal_alter('course_show_button', $result['success'], $node);
  if ($result['success']) {
    // The user is enrolled, purchased or was enrolled manually, and can take this course.
    // @todo move all uc course display logic to uc_course.module.
    if (!$node->field_addtl_products[0]['nid']) {
      // If course has additional products, don't hide the UC form.
      $node->content['add_to_cart']['#access'] = FALSE;
    }
    // Show the course button.
    return course_take_course_button_html($node);
  }
}

/**
 * Generate a button for taking the course.
 */
function course_take_course_button_html(&$node) {
  $course_button = module_invoke_all('course_button', $node);
  if (isset($course_button[0])) {
    return $course_button[0];
  }
  else {
    $link = l(t('Take Course'), "node/{$node->nid}/takecourse");
    return '<div class="action-link">' . $link . '</div>';
  }
}

/**
 * Enrols a user in a course.
 *
 * Timestamp is by design 0, so a user may purchase a course but start taking
 * it later.
 *
 * @param int NID of node.
 * @param int UID of user.
 */
function course_enrol(&$node, &$user, $from = NULL, $code = NULL, $status = 1) {
  if (course_node_is_course($node)) {
    $enrol = array(
      'nid' => $node->nid,
      'uid' => $user->uid,
      'enrollmenttype' => $from,
      'status' => $status,
      'code' => $code,
    );

    if ($node->course['duration'] > 0) {
      // Set enrolment end to now + the duration of the course.
      $enrol['enrol_end'] = time() + $node->course['duration'] * 86400;
    }

    $enrol = (object) $enrol;

    if (!course_enrolment_check($node, $user)) {
      // User is not enrolled yet.
      watchdog('course_enrol', "Enrolling user {$user->uid} into {$node->nid}");
      course_enrolment_save($enrol);
      $op = 'insert';
    }
    else {
      watchdog('course_enrol', "Re-enrolling user {$user->uid} into {$node->nid}");
      // return drupal_write_record('course_enrolment', $enrol, array('nid', 'uid'));
      $op = 'update';
    }
    // @todo figure $op out
    module_invoke_all('course_enrol', $node, $user, $from, $code, $status);
  }
  else {
    return FALSE;
  }
}

/**
 * Un-enroll the user.
 *
 * Deletes course report entries, course enrollments, and object fulfillment
 * records.
 *
 * @param object $node
 *   A course node.
 * @param object $user
 *   A user.
 * @return bool
 *   TRUE if user is un-enrolled, FALSE if node is not a course.
 */
function course_unenrol(&$node, &$user) {
  if (course_node_is_course($node)) {
    $sql = "delete from {course_report} where nid = %d and uid = %d";
    db_query($node->nid, $user->uid);
    $sql = "DELETE FROM {course_enrolment} where nid = %d and uid = %d";
    db_query($sql, $node->nid, $user->uid);
    // @todo change to delete w/left join
    $sql = "DELETE FROM {course_outline_fulfillment} WHERE uid = %d AND snid IN (SELECT snid FROM {course_outline} WHERE nid = %d)";
    db_query($sql, $user->uid, $node->nid);
    module_invoke_all('course_unenrol', $node, $user);
    watchdog('course_enrol', "Removed user {$user->uid} from {$node->nid}");
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Check if the user has enrolled in a course.
 *
 * @param mixed $node The course node.
 * @param mixed $user The user to check.
 *
 * @return bool TRUE if the user is enrolled, FALSE otherwise.
 */
function course_enrolment_check($nid, $uid) {
  if (is_object($nid)) {
    $nid = $nid->nid;
  }
  if (is_object($uid)) {
    $uid = $uid->uid;
  }

  if ($nid > 0 && $uid > 0) {
    $sql_check = "SELECT 1 FROM {course_enrolment} WHERE nid = %d AND uid = %d AND status = %d";
    $query = db_query($sql_check, $nid, $uid, 1);
    return db_result($query) > 0;
  }
  else {
    return FALSE;
  }
}

/**
 * Load an enrollment from a node ID and user ID.
 *
 * @param mixed $nid
 * @param mixed $uid
 * @return object or NULL
 */
function course_enrolment_load($nid, $uid) {
  if (is_object($nid)) {
    $nid = $nid->nid;
  }
  if (is_object($uid)) {
    $uid = $uid->uid;
  }

  $sql = "SELECT * FROM {course_enrolment} WHERE nid = %d AND uid = %d";
  return db_fetch_object(db_query($sql, $nid, $uid));
}

/**
 * Implementation of hook_enable().
 *
 * Insert course as product and add admin theme to course settings.
 */
function course_enable() {
  // Add course settings to admin theme.
  $paths = variable_get('admin_theme_path', '');
  if (strpos($paths, 'coursesettings') === FALSE) {
    $paths .= "\n*/coursesettings";
    variable_set('admin_theme_path', $paths);
  }
}

/**
 * Implementation of hook_form_alter().
 *
 * Hides Ubercart "add to cart button" if the user can take the course.
 * Show LMS selection.
 */
function course_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  $node = $form['#node'];

  if (course_node_is_course($node) && strpos($form_id, '_node_form') !== FALSE) {
    $lapps = course_available_lms();
    $options = array();
    $default_lms = variable_get("default_lms_{$node->type}", 'none');
    $lms_installed = FALSE;
    foreach ($lapps as $key => $lapp) {
      if (module_invoke($lapp['module'], 'lms_status', $key)) {
        $options[$key] = $lapp['name'];
        if ($key != 'none') {
          $lms_installed = TRUE;
        }
        if ($key == $default_lms) {
          $default_lms_installed = TRUE;
        }
      }
    }
    // Ensure LMS type set as default is still installed.
    $default_lms = $default_lms_installed ? $default_lms : 'none';
    if (!$lms_installed) {
      $messages = array();
      // Inform the user the lapp is not installed.
      $messages[] = t('The learning application for this course is not installed.');
      // Add additional information for course admins or learners.
      if ($is_course_admin) {
        $configure = url('admin/settings/course', array('query' => drupal_get_destination()));
        $messages[] = t('Please <a href="@configure">configure the Course module</a>.', array('@configure' => $configure));
      }
      else {
        $messages[] = t('Please contact the site administrator for more information.');
      }
      drupal_set_message(implode(' ', $messages), 'warning');
    }
    $form['course']['#tree'] = TRUE;
    $form['course']['#type'] = 'fieldset';
    $form['course']['#title'] = t('Course settings');
    $form['course']['#group'] = TRUE;
    $form['course']['lms'] = array(
      '#title' => t('LMS'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => $node->course['lms'] ? $node->course['lms'] : $default_lms,
      '#description' => 'This cannot be changed after saving.',
    );
    if ($node->course['lms'] != '') {
      drupal_set_title(t("@title (@lms)", array('@lms' => $lapps[$node->course['lms']]['name'], '@title' => $node->title)));
      $form['course']['lms']['#disabled'] = TRUE;
    }
    $form['course']['credits'] = array(
      '#title' => t('Credit hours'),
      '#type' => 'textfield',
      '#size' => 4,
      '#default_value' => $node->course['credits'],
      '#access' => FALSE,
    );
    $form['course']['open'] = array(
      '#title' => t('Release date'),
      '#type' => 'date_popup',
      '#default_value' => $node->course['open'],
      '#access' => FALSE,
    );
    $form['course']['close'] = array(
      '#title' => t('Expiration date'),
      '#type' => 'date_popup',
      '#default_value' => $node->course['close'],
      '#access' => FALSE,
    );
    $form['course']['duration'] = array(
      '#title' => 'Duration',
      '#type' => 'textfield',
      '#default_value' => $node->course['duration'],
      '#size' => 4,
      '#description' => 'Length in days a user can remain in the course. Enter 0 for unlimited.',
    );
    $form['course']['cid'] = array(
      '#title' => t('External LMS course ID'),
      '#description' => "If using an external LMS, the ID of the external course.",
      '#type' => 'textfield',
      '#default_value' => $node->course['cid'] !== NULL ? $node->course['cid'] : NULL,
      '#size' => 4,
      '#access' => FALSE,
    );
    $form['course']['external_id'] = array(
      '#title' => 'External course ID',
      '#description' => 'Course ID used to relate to an outside system.',
      '#type' => 'textfield',
      '#size' => 16,
      '#default_value' => $node->course['external_id'],
    );

    // Add the course objects form to the node form.
    // This worked for our initial requirements, but now, it's incredibly
    // complicated. Move to a tab. Maybe we'll bring this back as a UI
    // improvement. For the benefit of ctools and other libraries!
    //course_outline_overview_form($form, $form_state, $form_id);
  }

  if ($form_id == 'course_admin_settings') {
    $form['load_balanced_base_url'] = array(
      '#title' => 'Load Balanced Base URL',
      '#type' => 'textfield',
      '#description' => t('Optional. If this installation of Drupal is using a load balancer, it is recommended that you enter a domain here for API posts to work. Accepted format: <i>http://www.yoursitename.com</i>'),
      '#default_value' => variable_get('load_balanced_base_url', ''),
    );
  }
}

/**
 * Implementation of hook_form_FORM_ID_alter().
 */
function course_form_node_type_form_alter(&$form, &$form_state) {
  ctools_include('dependent');
  // Alter the node type's configuration form to add our setting.
  $form['course'] = array(
    '#type' => 'fieldset',
    '#title' => t('Course settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#access' => user_access('administer course'),
    '#group' => TRUE,
  );
  $form['course']['course_use'] = array(
    '#title' => t('Use as course type'),
    '#type' => 'checkbox',
    '#default_value' => variable_get("course_use_{$form['#node_type']->type}", 0),
  );
  // LMS options.
  $options = array('');
  $lapps = course_available_lms();
  foreach ($lapps as $key => $lapp) {
    if (module_invoke($lapp['module'], 'lms_status', $key)) {
      $options[$key] = $lapp['name'];
      if ($key != 'none') {
        $lms_installed = TRUE;
      }
    }
  }
  if (!$lms_installed) {
    $description = '<div class="messages warning">' . t('No LMS installed. Please <a href="@confirure">configure the Course module</a>.', array('@configure' => url('admin/settings/course'))) . '</div>';
  }
  $form['course']['default_lms'] = array(
    '#title' => t('Default LMS for %name', array('%name' => $form['#node_type']->name)),
    '#type' => 'select',
    '#options' => $options,
    '#default_value' => variable_get("default_lms_{$form['#node_type']->type}", 'none'),
    '#description' => $description,
    '#process' => array('ctools_dependent_process'),
    '#dependency' => array('edit-course-use' => array(1)),
  );

  // Configurable date fields.
  if (module_exists('date')) {
    $options = array();
    $options[0] = t('<Not specified>');
    $fields = content_fields();
    foreach ($fields as $field) {
      if ($field['module'] == 'date') {
        foreach ($field['columns'] as $column => $value) {
          if (in_array($column, array('value', 'value2'))) {
            $position = $column == 'value' ? 'From' : 'To';
            // Use the same label pattern as date_api_fields() for consistency
            // with Views, and in case we support other date options than
            // content date fields.
            $label = t('Content: !label (!name) - @position date', array('!label' => $field['widget']['label'], '!name' => $field['field_name'], '@position' => $position));
            #$key = "{$field['field_name']}[0]['{$column}']";
            $key = serialize(array('field' => $field['field_name'], 'value' => $column));
            $options[$key] = $label;
          }
        }
      }
    }
    // Enduring course dates.
    $form['course']['course_start_date'] = array(
      '#title' => t('Field to use for enduring-course start date'),
      '#description' => t('Select the field to use for enduring-course start date.'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get("course_start_date_{$form['#node_type']->type}", 0),
      '#prefix' => '<h3>' . t('Enduring course dates') . '</h3>',
    );
    $form['course']['course_expiration_date'] = array(
      '#title' => t('Field to use for enduring-course expiration date'),
      '#description' => t('Select the field to use for enduring-course expiration date.'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get("course_expiration_date_{$form['#node_type']->type}", 0),
    );
    // Live course dates.
    $form['course']['course_live_from_date'] = array(
      '#title' => t('Field to use for live-course start date'),
      '#description' => t('Select the field to use for live-course start date.'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get("course_live_from_date_{$form['#node_type']->type}", 0),
      '#prefix' => '<h3>' . t('Live course dates') . '</h3>',
    );
    $form['course']['course_live_to_date'] = array(
      '#title' => t('Field to use for live-course end date'),
      '#description' => t('Select the field to use for live-course end date.'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get("course_live_to_date_{$form['#node_type']->type}", 0),
    );
  }
}

/**
 * Generic Course IFrame function.
 *
 * @param $url
 * @param $height
 * @param $class
 */
function course_iframe($url = NULL, $height = '600px', $class = NULL) {
  $style = 'border:none; margin:0; width:100%; height:' . $height . ';';
  $iframe = '<iframe name="course-viewer" src="' . $url . '" style="' . $style . '" class="' . $class . '" scrolling="no" frameborder="0" onload="resizeFrame(this);"></iframe>';

  // Add JS to resize parent frame. This assumes additional JS on the targeted iframe content.
  drupal_add_js(drupal_get_path('module', 'course') . '/js/resizeframe.js');

  return $iframe;
}

/**
 * Invoke the LMS submodule's configuration form.
 */
function course_configure($lapp) {
  drupal_set_title('Course: Configure ' . $lapp['name']);
  $form_id = $lapp['module'] . '_lms_settings_form';
  return drupal_get_form('course_settings_form', $lapp);
}

/**
 * Form definition for submodule's configuration form.
 */
function course_settings_form($form_state, $lapp) {
  $form_id = $lapp['module'] . '_lms_settings_form';
  $form = $form_id($lapp['machine']);
  return system_settings_form($form);
}

/**
 * Fire submodule's implementation of course taking.
 */
function course_take_course($node) {
  global $user;
  drupal_set_title($node->title);

  $result = course_enrol_access($node);
  if ($result['success']) {
    $result = course_take_course_access($node);
  }
  if ($result['success'] === TRUE) {
    $enrolment = course_enrolment_load($node, $user);
    if (empty($enrolment->eid)) {
      // User has access to take this course, but they haven't been enrolled. So
      // enroll them now.
      $enrolment = course_enrol($node, $user);
    }
    if (empty($enrolment->timestamp)) {
      // If user hasn't started course, mark start of enrolment.
      $enrolment->timestamp = time();
      course_enrolment_save($enrolment);
      drupal_set_message("Your enrollment in this course has been recorded.");
    }
    $lapp = course_get_lms($node->course['lms']);
    return ($ret = module_invoke($lapp['module'], 'lms_take_course', $node->course['lms'], $node)) ? $ret : "hook_lms_take_course not implemented";
  }
  else {
    drupal_set_header('HTTP/1.1 403 Forbidden');
    drupal_set_title(t('Access denied'));
    if (empty($result['message'])) {
      return "Sorry, you do not have access to take this course. (No message provided by module).";
    }
    return "<h2>" . $result['header'] . "</h2>" . $result['message'];
  }
}

/**
 * Create or update an enrolment.
 */
function course_enrolment_save($enrolment) {
  if ($enrolment->nid && $enrolment->uid) {
    if (db_result(db_query('select 1 from {course_enrolment} where nid = %d and uid = %d', $enrolment->nid, $enrolment->uid))) {
      drupal_write_record('course_enrolment', $enrolment, array('nid', 'uid'));
    }
    else {
      drupal_write_record('course_enrolment', $enrolment);
    }
  }
  else {
    return FALSE;
  }

  return $enrolment;
}

/**
 * Fire submodule's implementation of course settings.
 */
function course_edit_course($node) {
  $lapp = course_get_lms($node->course['lms']);
  return ($ret = module_invoke($lapp['module'], 'lms_edit_course', $node->course['lms'], $node)) ? $ret : "hook_lms_edit_course not implemented";
}

/**
 * Get all available LMS.
 *
 * @todo Cache LMS apps?
 */
function course_available_lms() {
  static $lapps;
  if (!$lapps) {
    $lapps = module_invoke_all('lms_info');
  }

  uasort($lapps, '_course_weight_lapps');
  return $lapps;
}

function _course_weight_lapps($a1, $a2) {
  return $a1['weight'] > $a2['weight'];
}

/**
 * Build a list of available course objects from module implementations.
 *
 * @return array
 *   An array of course objects, keyed by module and then object key.
 */
function course_available_objects($reset = FALSE) {
  static $course_objects = array();

  if (!$course_objects || $reset) {
    $implementations = module_implements('course_object_info');
    $course_objects = array();
    foreach ($implementations as $implementor) {
      $objects = module_invoke($implementor, 'course_object_info');
      if (is_array($objects)) {
        foreach ($objects as $key => &$object) {
          if (!$object['module']) {
            $object['module'] = $implementor;
          }
          $course_objects[$object['module']][$key] = $object;
        }
      }
    }
    drupal_alter('course_object_info', $course_objects);
  }

  return $course_objects;
}

/**
 * Get a loaded course object.
 *
 * @param object $course
 *   The course node this object belongs to.
 * @param mixed $requirement_type
 *   The type, e.g. 'course_quiz', or an snid, or an object.
 * @param string $requirement_component
 *   The component, e.g. 'quiz'.
 * @param string $instance
 *   The instance ID (remote ID)
 * @param object $account
 *   The user for the fulfillment object.
 *
 *
 * @return object|boolean
 */
function course_get_course_object($requirement_type, $requirement_component = NULL, $instance = NULL, $account = NULL) {
  $available = course_available_objects();

  if (!$requirement_type) {
    return new CourseObject;
  }

  if (is_array($requirement_type)) {
    $requirement_type = (object) $requirement_type;
  }

  if (is_numeric($requirement_type)) {
    // Passed a course object ID. Load it from the database and return an object.
    $sql = 'select * from {course_outline} where snid = %d';
    $result = db_query($sql, $requirement_type);
    if ($row = db_fetch_object($result)) {
      $ret = $available[$row->requirement_type][$row->requirement_component];
      return new $ret['class']($row, $requirement_component);
    }
    else {
      return FALSE;
    }
  }

  if (is_object($requirement_type)) {
    // This is an already loaded course object.
    $outline_entry = $requirement_type;
    $account = $requirement_component;
  }
  else if (!is_null($instance)) {
    // Search for context.
    $sql = "select * from {course_outline}
      where requirement_type = '%s'
      and requirement_component = '%s'
      and instance = '%s'";
    $result = db_query($sql, $requirement_type, $requirement_component, $instance);
    if ($row = db_fetch_object($result)) {
      $outline_entry = $row;
    }
  }

  if (!$outline_entry) {
    $outline_entry = new stdClass;
    $outline_entry->requirement_type = $requirement_type;
    $outline_entry->requirement_component = $requirement_component;
    $outline_entry->instance = $instance;
  }

  $class = 'CourseObject';

  $ret = $available[$outline_entry->requirement_type][$outline_entry->requirement_component];

  if ($ret['class']) {
    $class = $ret['class'];
  }

  $courseObject = new $class($outline_entry, $account);
  if ($courseObject) {
    return $courseObject;
  }
  else {
    return FALSE;
  }
}

/**
 * Get specific LMS info by key.
 */
function course_get_lms($key) {
  $lapps = course_available_lms();
  return $lapps[$key];
}

/**
 * Check if node is a Course.
 *
 * @param $node
 *   A node object or string that indicates the node type to check.
 */
function course_node_is_course(&$node) {
  $type = is_object($node) ? $node->type : $node;
  return variable_get("course_use_{$type}", 0);
}

function course_views_plugins() {
  return array(
    'argument validator' => array(
      'course' => array(
        'title' => t('Course'),
        'handler' => 'views_plugin_argument_validate_course',
        'path' => drupal_get_path('module', 'course') . '/views/plugins',
      ),
    ),
  );
}

function course_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'course') . '/views',
  );
}

/**
 * Implementation of hook_content_extra_fields().
 */
function course_content_extra_fields($type) {
  $extras = array();

  if (course_node_is_course($type)) {
    $extras['course'] = array(
      'label' => t('Course settings'),
      'description' => t('Course settings and button.'),
    );
    $extras['course_outline'] = array(
      'label' => t('Course objects'),
      'description' => t('Course objects form.'),
    );
  }

  return $extras;
}

function course_preprocess_page(&$variables) {
  if (arg(2) == 'takecourse') {
    $regions = variable_get('course_disable_regions', array());
    foreach ($regions as $key => $region) {
      if ($region) {
        unset($variables[$region]);
      }
    }
  }

  if ($course = course_get_context()) {
    // Back/next buttons?
    //$variables['content'] .= 'sdfsdfsd';
  }
}

/**
 * Get a list of course types.
 */
function course_get_types() {
  $types = array();

  foreach (node_get_types() as $type => $info) {
    if (variable_get("course_use_$type", 0)) {
      $types[] = $type;
    }
  }

  return $types;
}

/**
 * Implementation of hook_token_list().
 */
function course_token_list($type = 'all') {
  $tokens = array();

  if ($type == 'node') {
    module_load_install('course');
    $schema = course_schema();
    foreach ($schema['course_node']['fields'] as $key => $value) {
      $tokens['course']["course-$key"] = $value['description'];
    }
  }

  return $tokens;
}

/**
 * Implementation of hook_token_values().
 */
function course_token_values($type, $object = NULL, $options = array()) {
  $values = array();

  if ($type == 'node') {
    $sql = 'select * from {course_node} where nid = %d';
    if ($course = db_fetch_object(db_query($sql, $object->nid))) {
      foreach ($course as $key => $value) {
        $values["course-$key"] = $value;
      }
    }
  }

  return $values;
}

/**
 * Implementation of hook_action_info().
 */
function course_action_info() {
  $actions = array();

  $actions['course_add_enrollment_action'] = array(
    'type' => 'user',
    'description' => t('Enroll user in current course'),
  );

  $actions['course_edit_enrollment_action'] = array(
    'type' => 'signup',
    'description' => t('Edit enrollment'),
    'configurable' => TRUE,
  );

  $actions['course_remove_enrollment_action'] = array(
    'type' => 'user',
    'description' => t('Remove a user from current course'),
  );

  return $actions;
}

/**
 * VBO to enrol a user in current course.
 *
 * @todo replace this with course object API implementation, in uc_course.
 */
function course_add_enrollment_action(&$user, $context) {
  if ($node = node_load(arg(1))) {
    course_enrol($node, $user);
    $reqs = course_outline_get_course_requirements($node);
    if (!empty($reqs)) {
      foreach ($reqs as $req) {
        if ($req->requirement_type == 'ubercart_payment') {
          $ubercart = array(
            'snid' => $req->snid,
            'uid' => $user->uid,
            'complete' => 1,
            'date_completed' => time(),
            'info' => 'Payment marked as complete because user was manually enrolled.',
          );
          course_outline_save_fulfillment($ubercart);
        }
      }
    }

    drupal_set_message(t("User @user enrolled in @node.", array('@user' => $user->name, '@node' => $node->title)));
  }
}

/**
 * Action to unenrol a user.
 */
function course_remove_enrollment_action(&$user, $context) {
  $node = node_load(arg(1));
  course_unenrol($node, $user);
}

/**
 * Edit enrolment action
 *
 * @todo use the CourseObject class for deleting/modifying/fulfilling
 * requirements
 *
 * @param type $signup
 * @param type $context
 */
function course_edit_enrollment_action(&$signup, $context) {
  $enrolment = new stdClass;
  $enrolment->uid = $signup->uid;
  $enrolment->nid = $signup->nid;
  if ($context['enrol_end']) {
    $unixtime = strtotime($context['enrol_end']);
    if ($unixtime) {
      $enrolment->enrol_end = $unixtime + 86399;
    }
  }
  if ($context['status'] != '') {
    $enrolment->status = $context['status'];
  }

  drupal_write_record('course_enrolment', $enrolment, array('nid', 'uid'));
  $node = node_load($enrolment->nid);
  $account = user_load($enrolment->uid);

  // Save completion.
  $report = course_report_load($node, $account);
  if ($context['complete'] != '') {
    $report->complete = $context['complete'];
    $report->nid = $node->nid;
    $report->uid = $account->uid;
    course_report_save($report);
  }

  $fulfillments = course_outline_check_remaining_requirements($node, $account);
  foreach ($fulfillments as $snid => $fulfillment) {
    if ($context['course_objects'][$snid] != '' && $fulfillment->complete != $context['course_objects'][$snid]) {
      // There was a change
      $fulfillment->complete = $context['course_objects'][$snid];
      $fulfillment->uid = $account->uid;
      $fulfillment->info = "Requirement \"{$fulfillment->title}\" updated via bulk action.";

      if ($fulfillment->complete == -1) {
        course_outline_delete_fulfillment($fulfillment);
      }
      else if ($fulfillment->complete == 0) {
        $fulfillment->complete = 0;
        $fulfillment->grade_result = 0;
        course_outline_save_fulfillment($fulfillment, TRUE);
      }
      else {
        course_outline_save_fulfillment($fulfillment);
      }
    }
  }

  drupal_set_message(t('Updated enrollment for @user', array('@user' => $account->name)));
}

function course_edit_enrollment_action_form($context) {
  $form = array();

  $node = node_load(arg(1));
  $num_users = count($context['selection']);

  $form['header'] = array(
    '#value' => 'Use this form to edit course enrollment and completion data for ' . format_plural($num_users, '1 user', '@c users', array('@c' => $num_users)) . '.',
  );

  if ($num_users == 1) {
    // Only one user, so let's prefill values.
    $selection = reset($context['selection']);
    // Toggle for VBO being added to a signup view.
    if ($selection->sid) {
      $uid = $selection->users_signup_log_uid;
    }
    else {
      $uid = $selection->uid;
    }
    $account = user_load($uid);
    // @todo use Course
    $fulfillments = course_outline_check_remaining_requirements($node, $account);

    $enrol = course_enrolment_load($node->nid, $account->uid);
    $course_report = course_report_load($node, $account);
  }

  $form['enrol_end'] = array(
    '#title' => 'Extend course enrollment until',
    '#type' => module_exists('date_popup') ? 'date_popup' : 'date',
    '#date_format' => 'm/d/Y',
    '#default_value' => $enrol->enrol_end ? date('U', $enrol->enrol_end) : NULL,
    '#description' => t('The date when the user will not be able to access the course.'),
  );

  $form['status'] = array(
    '#title' => 'Set enrollment status to',
    '#type' => 'select',
    '#options' => array(
      '' => '',
      1 => 'active',
      0 => 'inactive',
    ),
    '#default_value' => $enrol->status,
    '#description' => t('Setting an enrollment to "inactive" will prevent a user from accessing the course.'),
  );

  $form['complete'] = array(
    '#title' => 'Set completion status to',
    '#type' => 'select',
    '#options' => array(
      '' => '',
      1 => 'complete',
      0 => 'incomplete',
    ),
    '#description' => t("This will change a user's course completion. Set to incomplete this to re-evaluate all requirements. Course will never be automatically un-completed once they have been marked completed."),
    '#default_value' => $course_report->complete,
  );

  $form['course_objects'] = array(
    '#title' => 'Set completion status',
    '#description' => 'Set the status of a course object to be applied to selected users.',
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE,
    '#prefix' => '<span id="course-objects-wrapper">',
    '#suffix' => '</span>',
  );

  // deprecated, use Course
  $objects = course_outline_get_course_requirements($node);

  foreach ($objects as $snid => $object) {
    $form['course_objects'][$snid] = array(
      '#type' => 'select',
      '#title' => $object->title,
      '#options' => array(
        '' => '- no change - ',
        1 => 'Complete',
        -1 => 'Incomplete',
        0 => 'Failed',
      ),
      '#default_value' => $fulfillments[$snid]->complete,
    );
  }

  return $form;
}

function course_edit_enrollment_action_submit($form, $form_state) {
  return array(
    'enrol_end' => $form_state['values']['enrol_end'],
    'status' => $form_state['values']['status'],
    'complete' => $form_state['values']['complete'],
    'course_objects' => $form_state['values']['course_objects'],
  );
}

function course_edit_enrollment_action_validate($form, $form_state) {

}

/**
 * Implementatin of hook_init().
 */
function course_init() {
  // Determine context.
  if ($course_node = course_determine_context()) {
    course_set_context($course_node);
  }
}

/**
 * Implementation of hook_ctools_plugin_directory().
 */
function course_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools' && $plugin_type == 'content_types') {
    return 'plugins/content_types';
  }
}

/**
 * Form for configuring user types.
 */
function course_user_type_settings_form() {
  drupal_set_title('Course: Enrollment user types');

  $form = array();

  $form['header'] = array(
    '#value' => 'User types allow a user to select their type only for the enrollment duration of taking the course. For example, other modules may implement a mapping from the user type to course credit or a certificate while leaving a global profile field unchanged.',
  );

  $form['course_user_types_enabled'] = array(
    '#title' => 'Use course enrollment user types',
    '#type' => 'checkbox',
    '#validate' => 'course_user_type_settings_form_validate',
    '#default_value' => variable_get('course_user_types_enabled', ''),
  );

  $form['course_user_types_field'] = array(
    '#title' => 'Profile field to pull types from',
    '#type' => 'select',
    '#default_value' => variable_get('course_user_types_field', ''),
    '#options' => course_cck_kv_fields(),
  );

  $form['course_user_types'] = array(
    '#title' => 'Additional user types',
    '#type' => 'textarea',
    '#rows' => 5,
    '#validate' => 'course_user_type_settings_form_validate',
    '#default_value' => variable_get('course_user_types', ''),
    '#description' => 'Input course enrollment user types in the format "key|value", one per line.',
  );

  return system_settings_form($form);
}

function course_user_type_settings_form_validate(&$form, &$form_state) {
  $lines = explode("\n", trim($form_state['values']['course_user_types']));
  foreach ($lines as $line) {
    if (empty($line)) {
      return;
    }
    $kv = explode('|', $line);
    if (count($kv) != 2) {
      form_set_error('course_user_types', 'Each user type must be in key|value format.');
    }
  }
}

function course_cck_kv_fields() {
  $field_options = array();

  $field_options[] = 'none';

  if (module_exists('content')) {
    foreach (content_fields() as $key => $field) {
      // If field isn't a profile field with allowed values, do not allow it to be selectable. It wouldn't work anyways.
      if ($field['type_name'] == 'profile' && ($field['allowed_values'] != '' || $field['allowed_values_php'] != '')) {
        $field_options[$key] = $field['widget']['label'];
      }
    }
  }

  return $field_options;
}

/**
 * Get all the options for a user type selection.
 */
function course_user_type_get_options() {
  $field_name = variable_get('course_user_types_field', '');
  $options = array();

  if (!empty($field_name)) {
    $options = content_allowed_values(content_fields($field_name));
  }

  $lines = explode("\n", variable_get('course_user_types', ''));
  $additional = array();
  foreach ($lines as $line) {
    $line = explode('|', $line);
    if ($line[0]) {
      $additional[$line[0]] = $line[1];
    }
  }

  return array_merge($options, $additional);
}

/**
 * Implementation of course_credit_check_completion().
 *
 * Require the user to choose a user type before they claim credit.
 */
function course_course_credit_check_completion($course_node) {
  global $user;

  // Check if course user types enabled, has user types, and there is actually valid credit for this course.
  if (variable_get('course_user_types_enabled', 0) && count(course_user_type_get_options())) {
    // Check for active credit types. No user checking at this point.
    // @todo break out into function to get active credit types on a course.
    foreach ($course_node->course['credit'] as $ctid => $type) {
      if ($type->active) {
        $active = TRUE;
      }
    }
    if ($active) {
      $enrolment = course_enrolment_load($course_node, $user);
      if (!$enrolment->user_type) {
        drupal_goto("node/{$course_node->nid}/course-user-type", drupal_get_destination());
      }
    }
  }
}

/**
 * Allow the user to set their per-course user type.
 */
function course_user_type_form($form_state, $node) {
  $form = array();

  $form['#node'] = $node;

  $form['course_user_type'] = array(
    '#title' => 'Please select your user type',
    '#description' => 'Please select your user type. This will affect the credit and certificate you will receive.',
    '#options' => array_merge(array(''), course_user_type_get_options()),
    '#type' => 'select',
    '#required' => TRUE,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => 'Next',
  );

  return $form;
}

/**
 * Save the user's type in the course.
 */
function course_user_type_form_submit(&$form, $form_state) {
  global $user;

  $enrolment = course_enrolment_load($form['#node'], $user);
  $enrolment->user_type = $form_state['values']['course_user_type'];
  course_enrolment_save($enrolment);
}

/**
 * Check whether or not a user can self-enroll in a course.
 *
 * This function should be called by any module providing means
 * of self-enrollment (e.g., course_uc, course_signup) then act accordingly by
 * blocking that ability.
 *
 * Modules implementating hook_course_can_enrol should return the status and a
 * failure message. @see hook_course_can_enrol
 *
 * @staticvar array $courses
 *   Cache of hook results.
 * @param object $node
 *   A node.
 * @param object $user
 *   A user.
 * @return array
 *   An array with values 'success', to indicate whether or not the user
 *   has permission to self-enroll in this course, and 'message', a
 *   module-provided message that should be displayed to the user.
 */
function course_enrol_access($node, $user = NULL) {
  static $courses = array();

  if (!$user) {
    global $user;
  }

  if (!isset($courses[$node->nid])) {
    $courses[$node->nid]['success'] = TRUE;
    $hooks = module_invoke_all('course_can_enrol', $node, $user);
    foreach ($hooks as $key => $hook) {
      if (!$hook) {
        // Ok. Old style blocker. But look for messages.
        $courses[$node->nid] = FALSE;
      }
      if (is_array($hook) && !$hook['success']) {
        // New style blocker, return immediately.
        $courses[$node->nid] = $hook;
        return $hook;
      }
    }
  }

  return $courses[$node->nid];
}

/**
 * Implementation of hook_course_can_enrol().
 *
 * Block enrollments when a course has either not yet started or is expired.
 */
function course_course_can_enrol($node, $user) {
  $start = @unserialize(variable_get('course_start_date_' . $node->type, array()));
  $end = @unserialize(variable_get('course_expiration_date_' . $node->type, array()));

  if ($start && $end) {
    if ($node->course['type'] == 'enduring') {
      if (time() > strtotime($node->{$end['field']}[0]['value2'] . ' UTC')) {
        return array(array(
            'success' => FALSE,
            'message' => t('This course closed on %date and is no longer available for enrollments.', array(
              '%date' => format_date(strtotime($node->{$end['field']}[0]['value2']), 'custom', 'F, jS Y'),
            )),
          ));
      }
      else if (time() < strtotime($node->{$start['field']}[0]['value'] . ' UTC')) {
        return array(array(
            'success' => FALSE,
            'message' => t('This course opens on %date.', array(
              '%date' => format_date(strtotime($node->{$start['field']}[0]['value']), 'custom', 'F, jS Y'),
            )),
          ));
      }
    }
  }
}

/**
 * Inserts or updates a course report record. Check for missing fields.
 *
 * @param object $entry
 *   Object to be inserted or updated into the course report table. Required
 *   fields are nid (Drupal node ID) and uid (Drupal user ID).
 *
 * @todo Other fields are...
 */
function course_report_save($entry) {
  // No shenanigans.
  if (!$entry->nid > 0 || !$entry->uid > 0) {
    $message = t('Report not entered because entry must have nid and uid.');
    drupal_set_message($message, 'error');
    watchdog('course_report', $message, WATCHDOG_ERROR);
    return FALSE;
  }

  // Load user so we can serialize it.
  $account = user_load($entry->uid);

  // Load profile so we can serialize it.
  if (module_exists('content_profile')) {
    $content_profile = content_profile_load('profile', $entry->uid);
    if (!empty($content_profile)) {
      foreach ($content_profile as $key => $val) {
        if (strpos($key, 'field_') != FALSE) {
          $profile->${$key} = $val;
        }
      }
    }
  }
  $entry->data = serialize(array('user' => $account, 'profile' => $profile));

  $entry->updated = time();

  $sql = "select * from {course_report} where nid = %d and uid = %d";
  $query = db_query($sql, $entry->nid, $entry->uid);
  $old = db_fetch_object($query);


  //declare hook_course_report_alter for altering course report
  $course_report_alter = drupal_alter('course_report', $entry, $account, $old);

  if ($entry->complete && empty($entry->date_completed)) {
    $entry->date_completed = time();
  }

  // Hello CE credit!
  if ($old) {
    drupal_write_record('course_report', $entry, array('nid', 'uid'));
  }
  else {
    drupal_write_record('course_report', $entry);
  }

  module_invoke_all('course_report_saved', $entry, $account, $old);

  return $entry;
}

/**
 * Implementation of hook_user().
 *
 * Delete the user's course records, fulfillments, and enrollments upon
 * deletion.
 */
function course_user($op, &$edit, &$account, $category = NULL) {
  if ($op == 'delete') {
    $sql = "delete from {course_report} where uid = %d";
    db_query($sql, $account->uid);
    $sql = "DELETE FROM {course_outline_fulfillment} WHERE uid = %d";
    db_query($sql, $account->uid);
    $sql = "delete from {course_enrolment} where uid = %d";
    db_query($sql, $account->uid);
  }
}

/**
 * Implementation of hook_views_bulk_operations_object_info().
 *
 * Expose information about the course report object to VBO.
 */
function course_views_bulk_operations_object_info() {
  return array(
    'course_report' => array(
      'type' => 'course_report',
      'base_table' => 'course_report',
      'load' => 'course_report_load',
      'title' => 'name',
    )
  );
}

/**
 * Load a course report entry, by report entry ID or node/user object.
 *
 * @return object
 *   An object representation of a course report.
 */
function course_report_load($mixed, $user = NULL) {
  if (is_object($mixed)) {
    return db_fetch_object(db_query('select cr.* from {course_report} cr
    where nid = %d and uid = %d', $mixed->nid, $user->uid));
  }
  else if (is_numeric($user)) {
    return db_fetch_object(db_query('select cr.* from {course_report} cr
    where nid = %d and uid = %d', $mixed, $user));
  }
  else {
    return db_fetch_object(db_query('select cr.* from {course_report} cr
    where id = %d', $mixed));
  }
}

/**
 * Implementation of hook_theme().
 */
function course_theme() {
  return array(
    'course_outline_overview_form' => array(
      'form' => NULL,
    ),
    'course_report' => array(
      'file' => 'includes/course.reports.inc',
      'arguments' => array(
        'nav' => NULL,
        'header' => NULL,
        'body' => NULL,
      ),
    ),
  );
}

/**
 * Save a course object.
 *
 * Saves information about a course object and creates the course object.
 *
 * @param object $outline_entry
 *   Information about the course object.
 * @param object $node
 *   The course node to add this object to.
 * @return mixed
 *   A class that is an extension of CourseObject, NULL if nothing to do, FALSE
 *   if failure.
 */
function course_outline_save_requirement(&$outline_entry, $node = NULL) {
  $pair = explode('-', $outline_entry->requirement_component);

  if (count($pair) == 2) {
    $outline_entry->requirement_type = $pair[0];
    $outline_entry->requirement_component = $pair[1];
  }

  // Load a course object so we can work with it.
  $courseObject = course_get_course_object($outline_entry);

  if (!$courseObject->getId()) {
    // Only creating new course objects right now. Can't update them yet
    $courseObject->setCourseNid($node->nid);
  }

  $courseObject->save();
  return $courseObject;
}

/**
 * Delete a course requirement.
 *
 * @param array $mixed
 *   An array representing a course requirement (containing 'snid').
 */
function course_outline_delete_requirement($mixed) {
  if (is_object($mixed)) {
    $mixed = (array) $mixed;
  }
  $sql = "delete from {course_outline} where snid = %d";
  db_query($sql, $mixed['snid']);
  $sql = "delete from {course_outline_fulfillment} where snid = %d";
  db_query($sql, $mixed['snid']);
}

/**
 * Save a fulfillment record.
 *
 * Creates or updates a fulfillment record based on requirement ID and user ID.
 *
 * @param array $mixed
 *   An array of the fulfillment record to save. Must contain `snid` and `uid`.
 */
function course_outline_save_fulfillment($mixed) {
  if (!$fulfillment = course_outline_get_fulfillment($mixed->snid, $mixed->uid)) {
    // Doesn't exist
    drupal_write_record('course_outline_fulfillment', $mixed);
  }
  else {
    // Fulfillment record already exists.
    if ($fulfillment->complete) {
      // If it was previously complete, keep it.
      $mixed->complete = 1;
    }
    drupal_write_record('course_outline_fulfillment', $mixed, array('snid', 'uid'));
  }
}

/**
 * Get a fulfillment record from a requirement ID and user ID.
 *
 * @param int $snid
 *   The requirement ID.
 * @param int $uid
 *   The user ID.
 * @return object
 *   An object representing a fulfillment record.
 */
function course_outline_get_fulfillment($snid, $uid) {
  $results = db_query("SELECT * FROM {course_outline_fulfillment} WHERE snid = %d AND uid = %d", $snid, $uid);
  while ($row = db_fetch_array($results)) {
    return $row;
  }
  return FALSE;
}

/**
 * Get all the requirements for a course.

 * @param mixed $nid
 *   A course node object, or node identifier integer.
 * @return array
 *   An array of course outline objects.
 */
function course_outline_get_course_requirements($nid) {
  $requirements = array();

  if (is_object($nid)) {
    $nid = $nid->nid;
  }

  if ($nid) {
    $query = "SELECT *
      FROM {course_outline}
      WHERE nid = %d
      ORDER BY weight ASC";
    $result = db_query($query, $nid);
    while ($row = db_fetch_object($result)) {
      $requirements[$row->snid] = $row;
    }
  }

  return $requirements;
}

/**
 * Gets the course context.
 *
 * @todo support Context.
 */
function course_get_context() {
  return course_set_context();
}

/**
 * Sets a course context.
 *
 * @todo support Context.
 */
function course_set_context($node = NULL, $clear = FALSE) {
  static $stored_course_node;

  if ($clear) {
    $stored_course_node = NULL;
  }

  if (!empty($node)) {
    $stored_course_node = $node;
  }

  return (!empty($stored_course_node)) ? $stored_course_node : NULL;
}

/**
 * Get the course node from a requirement type + component + instance.
 *
 * @param string $requirement_type
 * @param string $requirement_component
 * @param string $instance
 *
 * @return mixed
 *   A course node or NULL if course context not found.
 */
function course_determine_context($requirement_type = NULL, $requirement_component = NULL, $instance = NULL) {
  $node = node_load(arg(1));
  if (course_node_is_course($node)) {
    return $node;
  }

  $sql = "select nid from {course_outline}
      where instance = '%s'
      and requirement_type = '%s'
      and requirement_component = '%s'";

  if ($course_nid = db_result(db_query($sql, $instance, $requirement_type, $requirement_component))) {
    return node_load($course_nid);
  }

  return NULL;
}
