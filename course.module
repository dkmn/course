<?php

/**
 * @file course.module
 * Core functionality for Courses.
 */
// Course Outline functions
require_once dirname(__FILE__) . '/includes/course.outline.inc';

/**
 * Implements hook_menu().
 */
function course_menu() {
  $items = array();

  // Base configuration.
  $items['admin/settings/course'] = array(
    'title' => 'Course',
    'description' => 'Configure courses.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_settings_overview'),
    'access arguments' => array('administer course'),
    'file' => 'includes/course.settings.inc',
  );

  // Default tab for settings.
  $items['admin/settings/course/overview'] = array(
    'title' => 'Overview',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['course/autocomplete/node/%'] = array(
    'page callback' => 'course_object_autocomplete_node',
    'access arguments' => array('access content'),
    'page arguments' => array(3, 4),
  );

  // Course settings handler forms. This gives organization and consistency to
  // form placement for each module that defines settings handlers through
  // hook_course_handlers().
  $modules = course_get_handlers('settings');
  $default_set = array();
  $handlers = array();
  $packages = array();
  // Flatten each module's settings handlers into one array, so we can get info
  // about any other handler-package while looping over each handler below.
  foreach ($modules as $module_key => $settings) {
    if (is_array($settings)) {
      // Define
      foreach ($settings as $handler_key => $handler_info) {
        // Manually set the implementing module key. It would be unnecessary to
        // force implementing modules to set this, since we can get it here.
        $handler_info['module'] = $module_key;

        // Manually set which package the handler belongs in. If one is not
        // defined, assume the handler is it's own package.
        $handler_info['package'] = isset($handler_info['package']) ? $handler_info['package'] : $handler_key;

        // Build the array of handlers. Add this handler with a combined key,
        // so module defined settings handlers can avoid namespace conflicts.
        $module_handler_key = "{$module_key}_{$handler_key}";
        $handlers[$module_handler_key] = $handler_info;

        // Build a reverse array of handler keys - keyed by package - so we can
        // get package info below when we need it. If there are duplicate
        // handler/package keys, use the first one for grouping the others.
        $package_key = $handler_info['package'] ? $handler_info['package'] : $handler_key;
        if (!isset($packages[$package_key])) {
          $packages[$package_key] = $module_handler_key;
        }
      }
    }
  }
  // Loop over each handler, and set tabs accordingly.
  foreach ($handlers as $module_handler_key => $handler_info) {
    // Get package info for this handler.
    $package_key = $handler_info['package'];
    $package_info = $handlers[$packages[$package_key]];

    // Define a path for the handler's specified package.
    $package_router = "admin/settings/course/{$package_key}";

    // Define a path for the handler.
    $handler_router = "admin/settings/course/{$package_key}/{$module_handler_key}";

    // Add the handler item, either as the default page content
    // (MENU_NORMAL_ITEM will work with the MENU_DEFAULT_LOCAL_TASK below)
    // or as one of the other MENU_LOCAL_TASK tabs). If this is the deafult
    // page content, the router path and title will be taken from the
    // handler which defined the package.
    $item_router = !isset($default_set[$package_key]) ? $package_router : $handler_router;
    $item_title = !isset($default_set[$package_key]) ? $package_info['name'] : $handler_info['name'];
    $item_type = !isset($default_set[$package_key]) ? MENU_NORMAL_ITEM : MENU_LOCAL_TASK;
    $items[$item_router] = array(
      'title' => $item_title,
      'description' => $handler_info['description'],
      'access arguments' => array('administer course'),
      'page callback' => 'drupal_get_form',
      'page arguments' => array($handler_info['callback']),
      'type' => $item_type,
    );
    // Append file info to $items, if specified.
    $file_info = array();
    if (isset($handler_info['file'])) {
      // Define the item 'file' key.
      $items[$item_router]['file'] = $handler_info['file'];
      // Define the item 'file path' key.
      if (isset($handler_info['file path'])) {
        // Use the path if provided. If not provided, we need to specify the
        // handler provider module path, otherwise hook_menu() assumes
        // 'file path' is the path to it's implementing module (Course).
        $items[$item_router]['file path'] = $handler_info['file path'] ? $handler_info['file path'] : drupal_get_path('module', $handler_info['module']);
      }
    }

    // Check if a default tab has already been set for this module.
    if (!isset($default_set[$package_key])) {
      // Add the default tab with the handler router item and name. We do
      // this here so the first handler settings form always displays as the
      // default page content at the module router item path.
      $items[$handler_router] = array(
        'title' => $handler_info['name'],
        'type' => MENU_DEFAULT_LOCAL_TASK,
        'weight' => -10,
      );
      // Flag MENU_DEFAULT_LOCAL_TASK as set for this module.
      $default_set[$package_key] = TRUE;
    }
  }

  // Per course user type selection.
  $items['node/%course/course-user-type'] = array(
    'title' => 'Choose user type',
    'description' => 'Allow the learner to choose their user type.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('course_user_type_form', 1),
    'access callback' => 'user_is_logged_in',
    'type' => MENU_CALLBACK,
  );

  // Landing page for course completion.
  $items['node/%course/course-outline'] = array(
    'title' => 'Course outline',
    'access arguments' => array('edit courses'),
    'page arguments' => array('course_outline_overview_form'),
    'page callback' => 'drupal_get_form',
    'type' => MENU_LOCAL_TASK,
    'file' => 'includes/course.outline.inc',
  );

  // Landing page for course completion.
  $items['node/%course/course-complete'] = array(
    'title' => 'Course completion',
    'access callback' => TRUE,
    'page arguments' => array(1),
    'page callback' => 'course_outline_show_complete_links',
    'type' => MENU_CALLBACK,
    'file' => 'includes/course.outline.inc',
  );


  // Display the 'Take course' menu item as a tab or link, depending.
  $items['node/%course/takecourse'] = array(
    'title' => 'Take course',
    'title callback' => 'course_takecourse_title',
    'title arguments' => array(1),
    'description' => 'Take course.',
    'page callback' => 'course_take_course',
    'page arguments' => array(1),
    'access callback' => 'course_take_course_menu_access',
    'access arguments' => array(1),
    'type' => variable_get('course_takecourse_tab_display', 1) ? MENU_LOCAL_TASK : MENU_CALLBACK,
  );

  // Display the 'Course settings' menu item as a tab or link, depending.
  $items['node/%course/coursesettings'] = array(
    'title' => 'Course settings',
    'description' => 'Course settings.',
    'page callback' => 'course_edit_course',
    'page arguments' => array(1),
    'access callback' => 'course_settings_menu_access',
    'access arguments' => array(1),
    'type' => MENU_CALLBACK,
  );

  // Reports page listing each course object.
  $items['node/%course/course-reports/objects'] = array(
    'title' => 'Course objects',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'course_object_reports_page',
    'page arguments' => array(1),
    'access arguments' => array('access course reports'),
    'file' => 'includes/course.reports.inc',
  );

  // Global report area
  $items['admin/reports/course'] = array(
    'title' => 'Course reports',
    'description' => 'View and download course information.',
    'access arguments' => array('access all course reports'),
    'page callback' => 'system_admin_menu_block_page',
    'file path' => drupal_get_path('module', 'system'),
    'file' => 'system.admin.inc',
  );

  // Course object
  $items['node/%course/course-object/%course_object'] = array(
    'title' => 'Course object router',
    'page callback' => 'course_object_take',
    'page arguments' => array(3),
    'access callback' => 'course_access_object',
    'access arguments' => array(1, 3),
  );

  // Course object edit
  $items['node/%course/course-object/%ctools_js/%course_object/edit'] = array(
    'title' => 'Course object settings',
    'page callback' => 'course_object_edit',
    'page arguments' => array(1, 3, 4),
    'access callback' => TRUE,
  );

  // Course object edit
  $items['node/%course/course-object/%ctools_js/%course_object/restore'] = array(
    'page callback' => 'course_object_restore',
    'page arguments' => array(1, 3, 4),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );

  // Course object settings link
  $items['node/%course/course-object/%ctools_js/store/%'] = array(
    'page callback' => 'course_store_temp_object',
    'page arguments' => array(1, 3, 5),
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  // AHAH handler.
  $items['node/%course/course-outline/%ctools_js/more/%'] = array(
    'page callback' => 'course_outline_overview_js_more',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'page arguments' => array(1, 3, 5),
  );

  $items['node/%course/course-object/%course_object/%ctools_js/nav'] = array(
    'page callback' => 'course_ajaj_fulfullment_check',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
    'page arguments' => array(1, 3, 5),
  );

  return $items;
}

/**
 * Implements hook_course_handlers().
 *
 * @see course_menu()
 * @see course_settings_overview()
 */
function course_course_handlers() {
  $outline = 'includes/course.outline.inc';
  $settings = 'includes/course.settings.inc';
  return array(
    'outline' => array(
      'course' => array(
        'name' => t('Course'),
        'description' => t('Stock outline display.'),
        'callback' => 'course_outline_list',
        'file' => $outline,
      ),
      'none' => array(
        'name' => t('None'),
        'description' => t('No outline provided (placeholder course).'),
      ),
    ),
    'context' => array(
      'node' => array(
        'callback' => 'course_context',
      ),
    ),
    'settings' => array(
      'appearance' => array(
        'name' => t('Appearance'),
        'description' => t('Configure the course appearance, including outline style, disabling regions, and <em>enroll</em> and <em>take course</em> links.'),
        'callback' => 'course_settings_appearance_form',
        'file' => $settings,
      ),
      'objects' => array(
        'name' => t('Course objects'),
        'description' => t('Course object settings.'),
        'callback' => 'course_settings_objects_form',
        'file' => $settings,
      ),
      'user_types' => array(
        'name' => t('User types'),
        'description' => t('Configure course user types.'),
        'callback' => 'course_user_type_settings_form',
        'file' => $settings,
      ),
    ),
  );
}

/**
 * Get course handlers.
 *
 * @param string $type
 *   (optional) The course handler type to return.
 *   If no type is specified, all types are returned.
 *
 * @return array
 *   A merged, structured array of course handlers returned by all
 *   implementations of hook_course_handlers(), optionally limited by type.
 *
 * @return array
 *   An array of hook implementations keyed by module name, containing:
 *   - A single handler type definition, if the $type parameter is passed.
 *   - Or an associative array of all course handler definitions keyed by type.
 */
function course_get_handlers($type = NULL, $flush = FALSE) {
  static $all = array();
  if (!$all || $flush) {
    // Allow modules to define handlers that extend Course functionality.
    // Do not use module_invoke_all() here because we need to know which module
    // is providing the 'object' handler type. This is to avoid namespace
    // conflicts between multiple modules providing a 'quiz' object for example.
    $hook = 'course_handlers';
    foreach (module_implements($hook) as $module) {
      $function = $module . '_' . $hook;
      $handlers = $function();

      // Allow modules to alter each other's list of handlers.
      drupal_alter($hook, $handlers, $module);

      if (isset($handlers) && is_array($handlers)) {
        $all[$module] = $handlers;
      }
    }
  }

  if (isset($type)) {
    // Loop through each module's result again, and rebuild the array including
    // only the specified handler type. We do this again so we can static cache
    // the hook invocation and function calls above.
    $filtered = array();
    foreach ($all as $module => $handlers) {
      if (isset($handlers[$type])) {
        $filtered[$module] = $handlers[$type];
      }
    }
    // Return the keyed array of implementations, each filtered to include only
    // the specified handler type definition.
    return $filtered;
  }
  else {
    // Return the keyed array of all implementations.
    return $all;
  }
}

/**
 * Menu access for course object router.
 */
function course_access_object($node, $courseObject) {
  global $user;
  $course = course_get_course($node, $user);
  $courseObject->setCourse($course);
  $course->setActive($courseObject->getId());
  return $courseObject->access('take');
}

function course_ajaj_fulfullment_check($node, $courseObject, $js = FALSE) {
  $courseObject->checkFulfillment();
  if (course_node_is_course($node)) {
    course_set_context($node);
  }
  module_load_include('inc', 'course', 'includes/course.block');
  $block = _course_block_navigation_view();
  drupal_json(array(
    'content' => $block['content'],
    'complete' => $courseObject->getFulfillment()->isComplete(),
  ));
}

/**
 * When a user selects a new object_type, update it in the database so
 * our modals etc use the right course object.
 *
 * @param type $node
 * @param type $js
 * @param type $uniqid
 */
function course_store_temp_object($node, $js, $uniqid) {
  if ($js) {
    $nid = $node->nid;
    $changed = explode('-', $_POST['ctools_changed']);
    $_SESSION['course'][$nid]['editing'][$uniqid]['module'] = $changed[0];
    $_SESSION['course'][$nid]['editing'][$uniqid]['object_type'] = $changed[1];
    ctools_include('ajax');
    $output = array();
    ctools_ajax_render($output);
  }
  else {
    exit;
  }
}

/**
 * Callback to restore a course object temporarily removed from outline overview
 * form.
 */
function course_object_restore($node, $js, CourseObject $courseObject) {
  $course = course_get_course($node);
  $courseObject->setCourse($course);
  $uniqid = $courseObject->getId();
  if ($js) {
    $nid = $node->nid;
    // Set the session value.
    $_SESSION['course'][$nid]['editing'][$uniqid]['delete'] = 0;
    $_SESSION['course'][$nid]['editing'][$uniqid]['delete_instance'] = 0;
    ctools_include('ajax');

    // Perform ajax operations on the overview form, after restore.
    $commands = array();

    // Reset summary.
    // @todo reload just this row. How?
    //$commands[] = ctools_ajax_command_replace("#row-{$uniqid}", $html);
    $commands[] = ctools_ajax_command_reload();

    ctools_ajax_render($commands);
  }
  else {
    exit;
  }
}

/**
 * Callback for modal window/nojs.
 */
function course_object_edit($node, $js, $courseObject) {
  $course = course_get_course($node);
  $courseObject->setCourse($course);
  if ($js) {
    ctools_include('ajax');
    ctools_include('modal');
    $form_state = array(
      'ajax' => TRUE,
      'title' => t("Settings for %t", array('%t' => $courseObject->getTitle())),
    );

    $form_state['args'][] = $courseObject;

    $output = ctools_modal_form_wrapper('course_object_edit_form', $form_state, $courseObject);
    if (empty($output)) {
      $output[] = ctools_modal_command_loading();
      $output[] = ctools_modal_command_dismiss();
    }
    ctools_ajax_render($output);
  }
  else {
    return drupal_get_form('course_object_edit_form', $courseObject);
  }
}

/**
 * Return the course object's edit form.
 */
function course_object_edit_form(&$form_state, $courseObject) {
  $form = array();
  $courseObject->optionsForm($form, $form_state);
  return $form;
}

function course_object_edit_form_validate(&$form, &$form_state) {
  if ($form_state['values']['uniqid']) {
    $nid = $form_state['values']['nid'];
    // Get course object from session/database.
    $courseObject = course_object_load($form_state['values']['uniqid']);
    $courseObject->setId($form_state['values']['uniqid']);
    $courseObject->optionsValidate($form, $form_state);
  }
}

function course_object_edit_form_submit(&$form, &$form_state) {
  if ($form_state['values']['uniqid']) {
    $nid = $form_state['values']['nid'];
    // Get course object from session/database.
    $courseObject = course_object_load($form_state['values']['uniqid']);
    $courseObject->setId($form_state['values']['uniqid']);
    $courseObject->optionsSubmit($form, $form_state);
  }
}

/**
 * Menu loader for course objects, in the context of a course.
 */
function course_object_load($coid) {
  global $user;
  $nid = arg(0) == 'node' && is_numeric(arg(1)) ? arg(1) : 0;
  if (!is_numeric($coid)) {
    // Temporary course object.
    $session = & $_SESSION['course'][$nid]['editing'][$coid];
    if ($courseObject = course_get_course_object($session['module'], $session['object_type'])) {
      $courseObject->setId($coid);
    }
  }
  else {
    // Stored course object.
    $courseObject = course_get_course_object_by_id($coid, $user);
  }

  if ($courseObject && $nid) {
    // If we're loading this from a menu loader, set the course.
    $courseObject->setCourse($nid);
  }
  
  return $courseObject;
}

/**
 * Take the course object.
 *
 * @return string
 *   Themed output.
 */
function course_object_take($courseObject) {
  drupal_set_title($courseObject->getTitle());

  // Preserve course tabs
  $course = $courseObject->getCourse();
  $item = menu_get_item($course->getUrl());
  menu_set_item(NULL, $item);

  return $courseObject->takeCourseObject();
}

/**
 * Implements hook_menu_alter().
 *
 * Look at a variable to determine the default course report. Did this to avoid
 * any one module having to define itself as a default local task.
 */
function course_menu_alter(&$items) {
  $default = variable_get('course_reports_default_report', 'node/%/course-reports/overview');

  if ($default) {
    $parent = $items[$default];
    $items[$default]['type'] = MENU_DEFAULT_LOCAL_TASK;
    $items[$default]['weight'] = -999;
    $parent['type'] = MENU_LOCAL_TASK;
    $parent['title'] = 'Course reports';
    $parent['access arguments'] = array('access course reports');
    $items['node/%course/course-reports'] = $parent;
  }
}

/**
 * Implements hook_block().
 */
function course_block($op = 'list', $delta = 0) {
  switch ($op) {
    case 'list':
      $info = array(
        'outline' => array('info' => t('Course: Outline'), 'cache' => BLOCK_NO_CACHE),
        'navigation' => array('info' => t('Course: Navigation'), 'cache' => BLOCK_NO_CACHE),
      );
      return $info;
    case 'configure':
    case 'view':
    case 'save':
      module_load_include('inc', 'course', 'includes/course.block');
      $function = "_course_block_{$delta}_{$op}";
      if (function_exists($function)) {
        return $function($edit);
      }
      break;
  }
}

/**
 * Menu title handler for the Take course tab.
 *
 * @return string
 *   "Review course" or "Take course", depending on the current user's
 *   completion status.
 */
function course_takecourse_title($node) {
  global $user;
  $report = course_report_load($node, $user);
  return ($user->uid > 1 && $report->complete) ? t('Review course') : t('Take course');
}

/**
 * Menu loader: check if node is a Course.
 */
function course_load($arg) {
  $node = node_load($arg);
  return course_node_is_course($node) ? $node : FALSE;
}

/**
 * Implements hook_perm().
 *
 * Define permissions to take courses and edit course settings.
 */
function course_perm() {
  return array(
    // Manage course settings
    'administer course',
    // Take courses
    'access course',
    // Edit course objects (not the node itself)
    'edit courses',
    // Can user get to the course reports area
    'access course reports',
    // Can use view all course reports
    'access all course reports',
  );
}

/**
 * Menu access callback to determins if the take course button should display
 * on the course node.
 *
 * This differs from course_take_course_access() as it only returns a boolean.
 *
 * @param object $node
 *   The course node.
 *
 * @see course_uc_token_values()
 */
function course_take_course_menu_access($node) {
  global $user;
  static $courses = array();

  if (!isset($courses[$node->nid])) {
    // Allow modules to restrict menu access to the take course tab.
    $hooks = module_invoke_all('course_has_takecourse', $node, $user);
    $courses[$node->nid] = !in_array(FALSE, $hooks);
  }

  return $courses[$node->nid];
}

/**
 * Menu access callback to determine if the course settings should tab should
 * display on the course node.
 *
 * This differs from course_settings_access() as it only returns a boolean.
 */
function course_settings_menu_access($node) {
  global $user;
  static $courses = array();

  if (!isset($courses[$node->nid])) {
    // Allow modules to restrict menu access to the course setting tab.
    $hooks = module_invoke_all('course_has_settings', $node, $user);
    $courses[$node->nid] = !in_array(FALSE, $hooks) && course_settings_access($node);
  }

  return $courses[$node->nid];
}

/**
 * Determine if taking this course should be restricted.
 *
 * @param object $node
 *   By reference. The course node.
 *
 * @return boolean|array
 *   Either FALSE, or an array containing:
 *   - success: Boolean. Indicates whether or not the user has permission to
 *     take this course.
 *   - message: String. If success is FALSE, a message to display to the user.
 */
function course_take_course_access($node, $account = NULL, $flush = FALSE) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  static $courses = array();

  // Don't let anonymous users see /takecourse. Also keeps from being indexed.
  if (arg(2) == 'takecourse' && !user_is_logged_in() && $_SERVER['SCRIPT_NAME'] != '/cron.php') {
    drupal_set_message(t('You must login or register before taking this course.'));
    drupal_goto('user/login', drupal_get_destination());
  }

  if (!isset($courses[$node->nid]) || $flush) {
    $courses[$node->nid]['success'] = TRUE;
    // Allow modules to determine if this course should be restricted.
    $hooks = module_invoke_all('can_take_course', $node, $account);
    foreach ($hooks as $key => $hook) {
      if (!$hook) {
        // Ok. Old style blocker. But look for messages.
        $courses[$node->nid] = FALSE;
      }
      if (is_array($hook) && !$hook['success']) {
        // New style blocker, return immediately.
        $courses[$node->nid] = $hook;
        return $hook;
      }
    }
  }

  if (is_array($courses[$node->nid])) {
    return $courses[$node->nid];
  }
  else {
    return array(
      'success' => $courses[$node->nid],
      'message' => "Old style blocker",
    );
  }
}

/**
 * Callback for checking course settings permission.
 */
function course_settings_access($node) {
  global $user;
  return ((user_access('edit own course products') || user_access('edit own course content')) && $node->uid == $user->uid) || user_access('edit courses');
}

/**
 * Implements hook_can_take_course().
 *
 * Check for built-in access restrictions (enrollment, release/expiration).
 *
 * @param object $node The course node.
 * @param object $user The user to check.
 */
function course_can_take_course($node, $user) {
  $sql = "select * from {course_enrolment} where nid = %d and uid = %d";
  if ($row = db_fetch_object(db_query($sql, $node->nid, $user->uid))) {
    if ($node->course['duration'] > 0 && time() > $row->enrol_end) {
      return array(array(
          'success' => FALSE,
          'message' => 'Sorry, your enrollment has expired for this course.',
        ));
    }
  }

  if ($node->course['closed']) {
    if ($node->course['type'] == 'enduring' && time() > strtotime($node->course['close'])) {
      return array(array(
          'success' => FALSE,
          'message' => 'Sorry, this course is expired.',
        ));
    }
  }
}

/**
 * Implements hook_nodeapi().
 *
 * When a course is saved, handles changes to the course outline and the
 * creation of external courses.
 *
 * Renders the "take course" button on view.
 */
function course_nodeapi(&$node, $op, $teaser = NULL, $page = NULL) {
  if (course_node_is_course($node)) {
    switch ($op) {
      case 'view':
        // Render take course button.
        $show = variable_get('course_take_course_button_show', array());
        if (($teaser && $show['teaser']) || ($page && $show['page'])) {
          $node->content['course']['#value'] = course_render_button($node);
        }
        break;
      case 'insert':
      case 'update':
        $record = $node->course;
        $record['nid'] = $node->nid;
        unset($record['open']);
        unset($record['close']);
        $existing = db_result(db_query('select 1 from {course_node} where nid = %d', $node->nid));
        $update = $existing ? array('nid') : array();
        drupal_write_record('course_node', $record, $update);
        break;
      case 'load':
        if ($course = db_fetch_array(db_query('select * from {course_node} where nid = %d', $node->nid))) {
          // Attach additional module provided info to $node->course.
          $hooks = module_invoke_all('course_nodeapi_extra', $node, 'load');
          $load = array_merge($course, $hooks);
          foreach ($load as $key => $data) {
            $node->course[$key] = $data;
          }
        }

        // Load the course outline to the node.
        $sql = "SELECT * FROM {course_outline}
          WHERE nid = %d
          ORDER BY weight ASC";
        $result = db_query($sql, $node->nid);
        while ($requirement = db_fetch_object($result)) {
          foreach ($requirement as $key => $value) {
            $rarray[$requirement->coid]->$key = $value;
          }
        }


        $node->course['objects'] = $rarray;
        break;
      case 'delete':
        // Clean up course specific settings and enrollments when a course is
        // deleted.
        db_query("DELETE FROM {course_node} where nid = %d", $node->nid);
        db_query("DELETE FROM {course_enrolment} where nid = %d", $node->nid);
        break;
    }
  }
}

/**
 * Check the permissions of showing the take course button, and return the HTML.
 */
function course_render_button($node) {
  global $user;

  $can_enrol = course_enrol_access($node, $user);

  if ($can_enrol['success']) {
    // User can self-enrol and take the course. Show the button.
    return course_take_course_button_html($node);
  }
}

/**
 * Generate a button for taking the course.
 */
function course_take_course_button_html(&$node) {
  // Allow modules to provide the course button.
  $course_button = module_invoke_all('course_button', $node);
  if (isset($course_button[0])) {
    return $course_button[0];
  }
  else {
    $link = l(t('Take Course'), "node/{$node->nid}/takecourse");
    return '<div class="action-link">' . $link . '</div>';
  }
}

/**
 * Enrols a user in a course.
 *
 * Timestamp is by design 0, so a user may purchase a course but start taking
 * it later.
 *
 * @param object $node
 *   By reference. The course node.
 * @param object $user
 *   By reference. The enrolling user.
 * @param string $from
 *   The type of enrollment, if applicable. {course_enrolment}.enrollmenttype.
 * @param string $code
 *   The access code used to enroll. {course_enrolment}.code.
 * @param integer $status
 *   The enrolment status. {course_enrolment}.status.
 */
function course_enrol($node, $account = NULL, $from = NULL, $code = NULL, $status = 1) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  if (course_node_is_course($node)) {
    $enrol = array(
      'nid' => $node->nid,
      'uid' => $account->uid,
      'enrollmenttype' => $from,
      'status' => $status,
      'code' => $code,
    );

    if ($node->course['duration'] > 0) {
      // Set enrolment end to now + the duration of the course.
      $enrol['enrol_end'] = time() + $node->course['duration'] * 86400;
    }

    $enrol = (object) $enrol;

    $watchdog_variables = array('!uid' => $account->uid, '!nid' => $node->nid);
    if (!course_enrolment_check($node, $account)) {
      // User is not enrolled yet.
      watchdog('course_enrol', 'Enrolling user !uid into !nid', $watchdog_variables);
      course_enrolment_save($enrol);
      $op = 'insert';
    }
    else {
      watchdog('course_enrol', 'Re-enrolling user !uid into !nid', $watchdog_variables);
      // return drupal_write_record('course_enrolment', $enrol, array('nid', 'uid'));
      $op = 'update';
    }
    // @todo figure $op out.
    // Notify modules about a course enrollment.
    module_invoke_all('course_enrol', $node, $account, $from, $code, $status);
  }
  else {
    return FALSE;
  }
}

/**
 * Un-enroll the user.
 *
 * Deletes course report entries, course enrollments, and object fulfillment
 * records.
 *
 * @param object $node
 *   A course node.
 * @param object $user
 *   A user.
 * @return bool
 *   TRUE if user is un-enrolled, FALSE if node is not a course.
 */
function course_unenrol(&$node, &$user) {
  if (course_node_is_course($node)) {
    $course = course_get_course($node, $user);
    $course->unenroll();
    $sql = "delete from {course_report} where nid = %d and uid = %d";
    db_query($sql, $node->nid, $user->uid);
    $sql = "DELETE FROM {course_enrolment} where nid = %d and uid = %d";
    db_query($sql, $node->nid, $user->uid);
    // @todo change to delete w/left join
    $sql = "DELETE FROM {course_outline_fulfillment} WHERE uid = %d AND coid IN (SELECT coid FROM {course_outline} WHERE nid = %d)";
    db_query($sql, $user->uid, $node->nid);
    // Notify other modules after course unenrollment.
    module_invoke_all('course_unenrol', $node, $user);
    $watchdog_variables = array('!uid' => $user->uid, '!nid' => $node->nid);
    watchdog('course_enrol', 'Removed user !uid from !nid', $watchdog_variables);
    return TRUE;
  }
  else {
    return FALSE;
  }
}

/**
 * Check if the user has enrolled in a course.
 *
 * @param mixed $node The course node.
 * @param mixed $user The user to check.
 *
 * @return bool TRUE if the user is enrolled, FALSE otherwise.
 */
function course_enrolment_check($nid, $uid) {
  if (is_object($nid)) {
    $nid = $nid->nid;
  }
  if (is_object($uid)) {
    $uid = $uid->uid;
  }

  if ($nid > 0 && $uid > 0) {
    $sql_check = "SELECT 1 FROM {course_enrolment} WHERE nid = %d AND uid = %d AND status = %d";
    $query = db_query($sql_check, $nid, $uid, 1);
    return db_result($query) > 0;
  }
  else {
    return FALSE;
  }
}

/**
 * Load an enrollment from a node ID and user ID.
 *
 * @param mixed $nid
 * @param mixed $uid
 * @return object or NULL
 */
function course_enrolment_load($nid, $uid) {
  if (is_object($nid)) {
    $nid = $nid->nid;
  }
  if (is_object($uid)) {
    $uid = $uid->uid;
  }

  $sql = "SELECT * FROM {course_enrolment} WHERE nid = %d AND uid = %d";
  return db_fetch_object(db_query($sql, $nid, $uid));
}

/**
 * Implements hook_enable().
 *
 * Insert course as product and add admin theme to course settings.
 */
function course_enable() {
  // Add course settings to admin theme.
  $paths = variable_get('admin_theme_path', '');
  if (strpos($paths, 'coursesettings') === FALSE) {
    $paths .= "\n*/coursesettings";
    variable_set('admin_theme_path', $paths);
  }

  // Flush autoload caches.
  autoload_flush_caches();
}

/**
 * Implements hook_form_alter().
 *
 * Course node settings form.
 *
 * @todo move this course node settings form to a secondary local task, under
 * the course settings tab.
 */
function course_form_alter(&$form, &$form_state, $form_id) {
  global $user;
  $node = $form['#node'];

  // Course node settings form.
  if (course_node_is_course($node) && strpos($form_id, '_node_form') !== FALSE) {
    $form['course']['#tree'] = TRUE;
    $form['course']['#type'] = 'fieldset';
    $form['course']['#title'] = t('Course settings');
    $form['course']['#group'] = TRUE;

    // Course outline display handler.
    $outlines = array();
    $handlers = course_get_handlers('outline');
    foreach ($handlers as $module => $outline_handlers) {
      if ($outline_handlers) {
        foreach ($outline_handlers as $key => $outline_handler) {
          $outlines[$key] = $outline_handler['name'];
        }
      }
    }

    $form['course']['outline'] = array(
      '#title' => t('Available outline displays'),
      '#type' => 'select',
      '#options' => $outlines,
      '#default_value' => $node->course['outline'],
    );

    $form['course']['credits'] = array(
      '#title' => t('Credit hours'),
      '#type' => 'textfield',
      '#size' => 4,
      '#default_value' => $node->course['credits'],
      '#access' => FALSE,
    );
    $form['course']['open'] = array(
      '#title' => t('Release date'),
      '#type' => 'date_popup',
      '#default_value' => $node->course['open'],
      '#access' => FALSE,
    );
    $form['course']['close'] = array(
      '#title' => t('Expiration date'),
      '#type' => 'date_popup',
      '#default_value' => $node->course['close'],
      '#access' => FALSE,
    );
    $form['course']['duration'] = array(
      '#title' => t('Duration'),
      '#type' => 'textfield',
      '#default_value' => $node->course['duration'],
      '#size' => 4,
      '#description' => t('Length in days a user can remain in the course. Enter 0 for unlimited.'),
    );
    $form['course']['cid'] = array(
      '#title' => t('External learning application course ID'),
      '#description' => t('If using an external learning application, the ID of the external course.'),
      '#type' => 'textfield',
      '#default_value' => $node->course['cid'] !== NULL ? $node->course['cid'] : NULL,
      '#size' => 4,
      '#access' => FALSE,
    );
    $form['course']['external_id'] = array(
      '#title' => t('External course ID'),
      '#description' => t('Course ID used to relate to an outside system.'),
      '#type' => 'textfield',
      '#size' => 16,
      '#default_value' => $node->course['external_id'],
    );
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function course_form_node_type_form_alter(&$form, &$form_state) {
  // Alter the node type's configuration form to add our setting.
  $form['course'] = array(
    '#type' => 'fieldset',
    '#title' => t('Course settings'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#access' => user_access('administer course'),
    '#group' => TRUE,
  );
  $form['course']['course_use'] = array(
    '#title' => t('Use as course type'),
    '#type' => 'checkbox',
    '#default_value' => variable_get("course_use_{$form['#node_type']->type}", 0),
  );

  // Ctools dependency.
  ctools_include('dependent');
  $dependent = array(
    '#process' => array('ctools_dependent_process'),
    '#dependency' => array('edit-course-use' => array(1)),
  );

  // Configurable date fields.
  if (module_exists('date')) {
    $options = array();
    $options[0] = t('<Not specified>');
    $fields = content_fields();
    foreach ($fields as $field) {
      if ($field['module'] == 'date') {
        foreach ($field['columns'] as $column => $value) {
          if (in_array($column, array('value', 'value2'))) {
            $position = $column == 'value' ? 'From' : 'To';
            // Use the same label pattern as date_api_fields() for consistency
            // with Views, and in case we support other date options than
            // content date fields.
            $label = t('Content: !label (!name) - @position date', array('!label' => $field['widget']['label'], '!name' => $field['field_name'], '@position' => $position));
            #$key = "{$field['field_name']}[0]['{$column}']";
            $key = serialize(array('field' => $field['field_name'], 'value' => $column));
            $options[$key] = $label;
          }
        }
      }
    }
    // Enduring course dates.
    $form['course']['course_start_date'] = array(
      '#title' => t('Field to use for enduring-course start date'),
      '#description' => t('Select the field to use for enduring-course start date.'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get("course_start_date_{$form['#node_type']->type}", 0),
      '#prefix' => '<h3>' . t('Enduring course dates') . '</h3>',
      ) + $dependent;
    $form['course']['course_expiration_date'] = array(
      '#title' => t('Field to use for enduring-course expiration date'),
      '#description' => t('Select the field to use for enduring-course expiration date.'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get("course_expiration_date_{$form['#node_type']->type}", 0),
      ) + $dependent;
    // Live course dates.
    $form['course']['course_live_from_date'] = array(
      '#title' => t('Field to use for live-course start date'),
      '#description' => t('Select the field to use for live-course start date.'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get("course_live_from_date_{$form['#node_type']->type}", 0),
      '#prefix' => '<h3>' . t('Live course dates') . '</h3>',
      ) + $dependent;
    $form['course']['course_live_to_date'] = array(
      '#title' => t('Field to use for live-course end date'),
      '#description' => t('Select the field to use for live-course end date.'),
      '#type' => 'select',
      '#options' => $options,
      '#default_value' => variable_get("course_live_to_date_{$form['#node_type']->type}", 0),
      ) + $dependent;
  }
}

/**
 * Generic Course IFrame function.
 *
 * @param string $url
 *   An iframe HTML element src attribute.
 * @param string $height
 *   A string representing an iframe height.
 * @param string $class
 *   A HTML class attribute for the iframe.
 */
function course_iframe($url = NULL, $height = '600px', $class = NULL) {
  $style = 'border:none; margin:0; width:100%; height:' . $height . ';';
  $iframe = '<iframe name="course-viewer" src="' . $url . '" style="' . $style . '" class="' . $class . '" scrolling="no" frameborder="0" onload="resizeFrame(this);"></iframe>';

  // Add JS to resize parent frame. This assumes additional JS on the targeted iframe content.
  drupal_add_js(drupal_get_path('module', 'course') . '/js/resizeframe.js');

  return $iframe;
}

/**
 * Take a course.
 *
 * - Enroll the user, if allowed.
 * - Block the user if not allowed.
 * - Fire the outline handler.
 */
function course_take_course($node) {
  global $user;
  drupal_set_title($node->title);

  $result = course_enrol_access($node);
  $enrolment = course_enrolment_load($node, $user);
  // Check enroll access or if user is already enrolled.
  if ($result['success'] || $enrolment->status) {
    $result = course_take_course_access($node);
  }
  if ($result['success'] === TRUE) {
    if (empty($enrolment->eid)) {
      // User has access to take this course, but they haven't been enrolled. So
      // enroll them now.
      $enrolment = course_enrol($node, $user);
    }
    if (empty($enrolment->timestamp)) {
      // If user hasn't started course, mark start of enrolment.
      $enrolment->timestamp = time();
      course_enrolment_save($enrolment);
      drupal_set_message(t('Your enrollment in this course has been recorded.'));
    }

    // Display the configured outline handler output.
    $key = $node->course['outline'] ? $node->course['outline'] : 'course';
    $handlers = course_get_handlers('outline');
    foreach ($handlers as $module => $outline_handlers) {
      if ($outline_handlers) {
        foreach ($outline_handlers as $key2 => $outline_handler) {
          if ($key == $key2) {
            $callback = $outline_handler['callback'];
          }
        }
      }
    }

    if (function_exists($callback)) {
      $outline = $callback($node, $user);
    }
    else {
      $outline = t('Outline not provided.');
    }

    if (!$outline) {
      $outline = t('No learning objects are available this time.');
    }

    return $outline;
  }
  else {
    drupal_set_header('HTTP/1.1 403 Forbidden');
    drupal_set_title(t('Access denied'));
    if (empty($result['message'])) {
      return t('Sorry, you do not have access to take this course. (No message provided by module).');
    }
    return "<h2>" . $result['header'] . "</h2>" . $result['message'];
  }
}

/**
 * Create or update an enrolment.
 */
function course_enrolment_save($enrolment) {
  if ($enrolment->nid && $enrolment->uid) {
    if (db_result(db_query('select 1 from {course_enrolment} where nid = %d and uid = %d', $enrolment->nid, $enrolment->uid))) {
      drupal_write_record('course_enrolment', $enrolment, array('nid', 'uid'));
    }
    else {
      if (!$enrolment->created) {
        $enrolment->created = time();
      }
      drupal_write_record('course_enrolment', $enrolment);
    }
  }
  else {
    return FALSE;
  }
}

/**
 * Get a course object by its identifier.
 *
 * @param int $coid
 *   The numeric ID of the course object.
 * @param stdClass $account
 *   If specified the CourseObject will be loaded with this user (for access and
 *   fulfillment tracking).
 *
 * @return CourseObject|FALSE
 *   A loaded CourseObject or FALSE if no object found.
 */
function course_get_course_object_by_id($coid, $account = NULL, $course = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  $available = course_get_handlers('object');

  $sql = 'select * from {course_outline} where coid = %d';
  $result = db_query($sql, $coid);
  if ($row = db_fetch_object($result)) {
    $ret = $available[$row->module][$row->object_type];
    if (!class_exists($ret['class'])) {
      drupal_set_message(t("Could not find class for %m-%c!", array('%m' => $row->module, '%c' => $row->object_type)), 'error');
      return FALSE;
    }
    else {
      if (!$course) {
        $course = new Course(node_load($row->nid), $account);
      }
      return new $ret['class']($row, $account, $course);
    }
  }
  else {
    return FALSE;
  }
}

/**
 * CourseObject factory. Get a loaded course object from database or build one
 * from arguments.
 *
 * @param mixed $module
 *   The module name of this course object, or an array resembling a row in the
 *   {course_outline} table.
 * @param string $object_type
 *   The object type belonging to the module.
 * @param string $instance
 *   The course object instance ID, from {course_outline}.instance.
 * @param stdClass $account
 *   The user object. This will instantiate a fulfillment record on the returned
 *   CourseObject.
 * @param Course $course
 *   The Course to pass to the CourseObject instantiation.
 *
 * @return CourseObject|FALSE
 */
function course_get_course_object($module, $object_type = NULL, $instance = NULL, $account = NULL, $course = NULL) {
  $available = course_get_handlers('object');

  $fulfillment = FALSE;
  if ($account) {
    // Account was passed. We are preparing for fulfillment.
    $fulfillment = TRUE;
  }

  if (!$account) {
    global $user;
    $account = $user;
  }

  if (is_array($module)) {
    // Cast array passed to an object.
    $module = (object) $module;
  }

  if (is_object($module) && $module->coid) {
    // Passed options with the course object ID set.
    $coid = $module->coid;
    return course_get_course_object_by_id($coid, $account, $course);
  }

  if (is_numeric($module)) {
    $coid = $module;
  }
  elseif (is_object($module)) {
    // This is an already loaded (but not saved) course object.
    $outline_entry = $module;
  }
  elseif (!is_null($instance)) {
    // Get the course context.
    if (!$course) {
      if ($courseNode = course_determine_context($module, $object_type, $instance, TRUE, FALSE)) {
        $course = new Course($courseNode, $account);
      }
    }

    // Search for context.
    $sql = "select * from {course_outline}
      where module = '%s'
      and object_type = '%s'
      and instance = '%s'";
    $result = db_query($sql, $module, $object_type, $instance);
    while ($row = db_fetch_object($result)) {
      $outline_entries[$row->nid] = $row;
    }

    if ($outline_entries) {
      // Found some course objects.
      //
      // Either the active course is in the courses this instance is in, or, the
      // active course wasn't a parent of any course object found, so use the
      // first object found.
      $coid = $outline_entries[$courseNode->nid] ? $outline_entries[$courseNode->nid]->coid : reset($outline_entries)->coid;
      return course_get_course_object_by_id($coid, $account);
    }
  }

  if (!$outline_entry) {
    if ($fulfillment) {
      // Doing fulfillment, we need a persistent CourseObject.
      return FALSE;
    }
    else {
      // Couldn't find context, and not checking for fulfillment. We can safely
      // construct a new CourseObject.
      $outline_entry = new stdClass;
      $outline_entry->module = $module;
      $outline_entry->object_type = $object_type;
      $outline_entry->instance = $instance;
    }
  }

  $ret = $available[$outline_entry->module][$outline_entry->object_type];

  if ($ret['class']) {
    $class = $ret['class'];
  }
  else {
    return FALSE;
  }

  $courseObject = new $class($outline_entry, $account, $course);
  if ($courseObject) {
    return $courseObject;
  }
  else {
    return FALSE;
  }
}

/**
 * Get a loaded Course.
 *
 * @param object $node
 *   The course node object.
 *
 * @return Course
 */
function course_get_course($node, $account = NULL) {
  if (!$account) {
    global $user;
    $account = $user;
  }

  static $courses = array();

  if (!isset($courses[$node->nid][$account->uid])) {
    $course = new Course($node, $account);
    $courses[$node->nid][$account->uid] = $course;
  }

  return $courses[$node->nid][$account->uid];
}

/**
 * Check if node is a Course.
 *
 * @param stdClass $node
 *   A node object or string that indicates the node type to check.
 *
 * @return bool
 */
function course_node_is_course(&$node) {
  $type = is_object($node) ? $node->type : $node;
  return variable_get("course_use_{$type}", 0);
}

/**
 * Implements hook_views_plugins().
 */
function course_views_plugins() {
  return array(
    'argument validator' => array(
      'course' => array(
        'title' => t('Course'),
        'handler' => 'views_plugin_argument_validate_course',
        'path' => drupal_get_path('module', 'course') . '/views/plugins',
      ),
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function course_views_api() {
  return array(
    'api' => 2,
    'path' => drupal_get_path('module', 'course') . '/views',
  );
}

/**
 * Implements hook_content_extra_fields().
 */
function course_content_extra_fields($type) {
  $extras = array();

  if (course_node_is_course($type)) {
    $extras['course'] = array(
      'label' => t('Course settings'),
      'description' => t('Course settings and button.'),
    );
    $extras['course_outline'] = array(
      'label' => t('Course objects'),
      'description' => t('Course objects form.'),
    );
  }

  return $extras;
}

/**
 * Implements hook_preprocess_page().
 */
function course_preprocess_page(&$variables) {
  if (arg(2) == 'takecourse') {
    $regions = variable_get('course_disable_regions', array());
    foreach ($regions as $key => $region) {
      if ($region) {
        unset($variables[$region]);
      }
    }
  }

  if ($course = course_get_context()) {
    // Back/next buttons?
    //$variables['content'] .= 'sdfsdfsd';
  }
}

/**
 * Get a list of course types.
 *
 * @return array
 */
function course_get_types() {
  $types = array();

  foreach (node_get_types() as $type => $info) {
    if (variable_get("course_use_$type", 0)) {
      $types[] = $type;
    }
  }

  return $types;
}

/**
 * Implements hook_token_list().
 */
function course_token_list($type = 'all') {
  $tokens = array();

  if ($type == 'node') {
    module_load_install('course');
    $schema = course_schema();
    foreach ($schema['course_node']['fields'] as $key => $value) {
      $tokens['course']["course-$key"] = $value['description'];
    }
  }

  return $tokens;
}

/**
 * Implements hook_token_values().
 */
function course_token_values($type, $object = NULL, $options = array()) {
  $values = array();

  if ($type == 'node') {
    $sql = 'select * from {course_node} where nid = %d';
    if ($course = db_fetch_object(db_query($sql, $object->nid))) {
      foreach ($course as $key => $value) {
        $values["course-$key"] = $value;
      }
    }
  }

  return $values;
}

/**
 * Implements hook_action_info().
 */
function course_action_info() {
  $actions = array();

  $actions['course_add_enrollment_action'] = array(
    'type' => 'user',
    'description' => t('Enroll user in current course'),
  );

  $actions['course_edit_enrollment_action'] = array(
    'type' => 'signup',
    'description' => t('Edit enrollment'),
    'configurable' => TRUE,
  );

  $actions['course_remove_enrollment_action'] = array(
    'type' => 'user',
    'description' => t('Remove a user from current course'),
  );

  return $actions;
}

/**
 * Action to enrol a user in current course.
 */
function course_add_enrollment_action($user, $context) {
  if ($node = node_load(arg(1))) {
    course_enrol($node, $user);
    drupal_set_message(t("Enrolled %name in %title.", array('%name' => $user->name, '%title' => $node->title)));
  }
}

/**
 * Action to unenrol a user.
 */
function course_remove_enrollment_action(&$user, $context) {
  $node = node_load(arg(1));
  course_unenrol($node, $user);
}

/**
 * Edit enrolment action
 *
 * @param object $object
 *   An object containing nid and uid properties.
 * @param array $context
 *   Values from user input.
 */
function course_edit_enrollment_action($object, $context) {
  $enrollment = course_enrolment_load($object->nid, $object->uid);
  $node = node_load($enrollment->nid);
  $account = user_load($enrollment->uid);
  $course_report = course_report_load($node, $account);

  // Update enrollment status.
  if ($context['status'] != '') {
    $enrollment->status = $context['status'];
  }

  // Update enrollment duration.
  if ($context['enrol_end']) {
    // Parse date from popup/plain text.
    if ($unixtime = strtotime($context['enrol_end'])) {
      $enrollment->enrol_end = $unixtime + 86399;
    }
  }

  // Update completion.
  if ($context['complete'] != '') {
    $course_report->complete = $context['complete'];
  }

  // Update date completed.
  if ($context['date_completed'] != '') {
    if ($unixtime = strtotime($context['date_completed'])) {
      $course_report->date_completed = $unixtime;
    }
  }

  course_enrolment_save($enrollment);
  course_report_save($course_report);

  $course = course_get_course($node, $account);
  foreach ($course->getObjects() as $key => $courseObject) {
    $coid = $courseObject->getId();
    $fulfillment = $courseObject->getFulfillment();
    if ($context['course_objects'][$coid] != '') {
      // There was a change

      if ($context['course_objects'][$coid] == 1) {
        // Completed
        $fulfillment->setOption('message', "Fulfillment completed via bulk action.");
        $fulfillment->setComplete($context['course_objects'][$coid]);
      }

      if ($context['course_objects'][$coid] == -1) {
        // Delete attempt
        $fulfillment->delete();
      }

      if ($context['course_objects'][$coid] == 0) {
        // Fail user
        $fulfillment->setOption('message', "Fulfillment failed via bulk action.");
        $fulfillment->setComplete(FALSE);
        $fulfillment->setOption('failed', TRUE);
      }

      $fulfillment->save();
    }
  }

  drupal_set_message(t('Updated enrollment for %user', array('%user' => $account->name)));
}

/**
 * Edit enrollment action form.
 */
function course_edit_enrollment_action_form($context) {
  $form = array();

  $node = node_load(arg(1));
  $num_users = count($context['selection']);

  $form['header'] = array(
    '#value' => format_plural($num_users, 'Use this form to edit course enrollment and completion data for 1 user', 'Use this form to edit course enrollment and completion data for @count users'),
  );

  if ($num_users == 1) {
    // Only one user, so let's prefill values.
    $selection = reset($context['selection']);
    // Toggle for VBO being added to a signup view.
    if ($selection->sid) {
      $uid = $selection->users_signup_log_uid;
    }
    else {
      $uid = $selection->uid;
    }
    $account = user_load($uid);
    // @todo use Course
    $fulfillments = course_outline_check_remaining_requirements($node, $account);

    $enrol = course_enrolment_load($node->nid, $account->uid);
    $course_report = course_report_load($node, $account);
  }

  $form['status'] = array(
    '#title' => t('Set enrollment status to'),
    '#type' => 'select',
    '#options' => array(
      '' => '',
      1 => 'Active',
      0 => 'Inactive',
    ),
    '#default_value' => $enrol->status,
    '#description' => t('Setting an enrollment to "inactive" will prevent a user from accessing the course.'),
  );

  $form['enrol_end'] = array(
    '#title' => t('Extend course enrollment until'),
    '#type' => module_exists('date_popup') ? 'date_popup' : 'date_text',
    '#date_format' => 'm/d/Y H:i',
    '#description' => t('The date when the user will not be able to access the course.'),
    '#default_value' => date('Y-m-d H:i:s', $enrol->enrol_end),
  );


  $form['complete'] = array(
    '#title' => t('Set completion status to'),
    '#type' => 'select',
    '#options' => array(
      '' => '',
      1 => t('Complete'),
      0 => t('Incomplete'),
    ),
    '#description' => t("This will change a user's course completion. Set to incomplete this to re-evaluate all requirements. Course will never be automatically un-completed once they have been marked completed."),
    '#default_value' => $course_report->complete,
  );

  $form['date_completed'] = array(
    '#title' => t('Set completion date to'),
    '#type' => module_exists('date_popup') ? 'date_popup' : 'date_text',
    '#date_format' => 'm/d/Y H:i',
    '#description' => t('The date of completion.'),
    '#default_value' => date('Y-m-d H:i:s', $course_report->date_completed),
  );

  $form['course_objects'] = array(
    '#title' => t('Set completion status'),
    '#description' => t('Set the status of a course object to be applied to selected users.'),
    '#type' => 'fieldset',
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
    '#tree' => TRUE,
    '#prefix' => '<span id="course-objects-wrapper">',
    '#suffix' => '</span>',
  );

  $course = course_get_course($node);

  foreach ($course->getObjects() as $key => $courseObject) {
    $form['course_objects'][$courseObject->getId()] = array(
      '#type' => 'select',
      '#title' => check_plain($courseObject->getTitle()),
      '#options' => array(
        '' => '- no change - ',
        1 => t('Complete'),
        -1 => t('Incomplete'),
        0 => t('Failed'),
      ),
      '#default_value' => $fulfillments[$courseObject->getId()]->complete,
    );
  }

  return $form;
}

/**
 * Submit handler for course_edit_enrollment_action_form().
 */
function course_edit_enrollment_action_submit($form, $form_state) {
  return array(
    'enrol_end' => $form_state['values']['enrol_end'],
    'status' => $form_state['values']['status'],
    'complete' => $form_state['values']['complete'],
    'date_completed' => $form_state['values']['date_completed'],
    'course_objects' => $form_state['values']['course_objects'],
  );
}

function course_edit_enrollment_action_validate($form, $form_state) {

}

/**
 * Implements hook_init().
 */
function course_init() {
  course_context();

  if (!$courseNode = course_get_context()) {
    // Set course context for all modules that define course context handlers.
    // @see hook_course_handlers().
    $modules = course_get_handlers('context');
    foreach ($modules as $module => $handlers) {
      if (is_array($handlers)) {
        foreach ($handlers as $handler) {
          $callback = $handler['callback'];

          // Calculate and include the file for each callback, if specified.
          if ($handler['file']) {
            $file_path = $handler['file path'] ? $handler['file path'] : drupal_get_path('module', $module);
            $include_file = $file_path . '/' . $handler['file'];
            include_once($include_file);
          }

          // We expect query parameters suitable for course_determine_context().
          if (function_exists($callback)) {
            $params = $callback();
            if (is_array($params) && isset($params['object_type']) && isset($params['instance'])) {
              if ($courseNode = course_determine_context($module, $params['object_type'], $params['instance'])) {
                course_set_context($courseNode);
              }
            }
          }
        }
      }
    }
  }

  if (class_exists('Course')) {
    // Check that Course exists for a special use case where Autoload hasn't yet
    // cached the Course class.

    $course = course_get_course($courseNode);
    if ($course && $course->getActive()) {
      drupal_add_js(
        array(
        'courseAjaxNavPath' => url('node/' . $courseNode->nid . '/course-object/' . $course->getActive()->getId() . '/ajax/nav'),
        ), 'setting'
      );
    }
  }
}

/**
 * Course context handler callback.
 */
function course_context() {
  if (arg(0) == 'node') {
    // If we are on the course node, set the context immediately.
    $node = node_load(arg(1));
    if (course_node_is_course($node)) {
      course_set_context($node);
    }
  }
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function course_ctools_plugin_directory($owner, $plugin_type) {
  if ($owner == 'ctools' && $plugin_type == 'content_types') {
    return 'plugins/content_types';
  }
  if ($owner == 'course') {
    return "plugins/course/$plugin_type";
  }
}

/**
 * Implements course_credit_check_completion().
 *
 * Require the user to choose a user type before they claim credit.
 */
function course_course_credit_check_completion($course_node) {
  global $user;

  // Check if course user types enabled, has user types, and there is actually valid credit for this course.
  if (variable_get('course_user_types_enabled', 0) && count(course_user_type_get_options())) {
    // Check for active credit types. No user checking at this point.
    // @todo break out into function to get active credit types on a course.
    foreach ($course_node->course['credit'] as $ctid => $type) {
      if ($type->active) {
        $active = TRUE;
      }
    }
    if ($active) {
      $enrolment = course_enrolment_load($course_node, $user);
      if (!$enrolment->user_type) {
        drupal_goto("node/{$course_node->nid}/course-user-type", drupal_get_destination());
      }
    }
  }
}

/**
 * Allow the user to set their per-course user type.
 */
function course_user_type_form($form_state, $node) {
  $form = array();

  $form['#node'] = $node;

  $form['course_user_type'] = array(
    '#title' => t('Please select your user type'),
    '#description' => t('Please select your user type. This will affect the credit and certificate you will receive.'),
    '#options' => array_merge(array(''), course_user_type_get_options()),
    '#type' => 'select',
    '#required' => TRUE,
  );

  $form['submit'] = array(
    '#type' => 'submit',
    '#value' => t('Next'),
  );

  return $form;
}

/**
 * Save the user's type in the course.
 */
function course_user_type_form_submit(&$form, $form_state) {
  global $user;

  $enrolment = course_enrolment_load($form['#node'], $user);
  $enrolment->user_type = $form_state['values']['course_user_type'];
  course_enrolment_save($enrolment);
}

/**
 * Check whether or not a user can self-enroll in a course.
 *
 * This function should be called by any module providing means
 * of self-enrollment (e.g., course_uc, course_signup) then act accordingly by
 * blocking that ability.
 *
 * @staticvar array $courses
 *   Cache of hook results.
 * @param object $node
 *   A node.
 * @param object $user
 *   A user.
 * @return array
 *   An array with values 'success', to indicate whether or not the user
 *   has permission to self-enroll in this course, and 'message', a
 *   module-provided message that should be displayed to the user.
 */
function course_enrol_access($node, $user = NULL, $flush = FALSE) {
  static $courses = array();

  if (!$user) {
    global $user;
  }

  if (!isset($courses[$node->nid]) || $flush) {
    $courses[$node->nid]['success'] = TRUE;
    // Allow modules to set self-enrollment access for a user.
    $hooks = module_invoke_all('course_can_enrol', $node, $user);
    foreach ($hooks as $key => $hook) {
      if (!$hook) {
        // Ok. Old style blocker. But look for messages.
        $courses[$node->nid] = FALSE;
      }
      if (is_array($hook) && !$hook['success']) {
        // New style blocker, return immediately.
        $courses[$node->nid] = $hook;
        return $hook;
      }
    }
  }

  return $courses[$node->nid];
}

/**
 * Implements hook_course_can_enrol().
 *
 * Block enrollments when a course has either not yet started or is expired.
 */
function course_course_can_enrol($node, $user) {
  $start = @unserialize(variable_get('course_start_date_' . $node->type, array()));
  $end = @unserialize(variable_get('course_expiration_date_' . $node->type, array()));

  if ($start && $end) {
    if ($node->course['type'] == 'enduring') {
      if (time() > strtotime($node->{$end['field']}[0]['value2'] . ' UTC')) {
        return array(array(
            'success' => FALSE,
            'message' => t('This course closed on %date and is no longer available for enrollments.', array(
              '%date' => format_date(strtotime($node->{$end['field']}[0]['value2']), 'custom', 'F, jS Y'),
            )),
          ));
      }
      elseif (time() < strtotime($node->{$start['field']}[0]['value'] . ' UTC')) {
        return array(array(
            'success' => FALSE,
            'message' => t('This course opens on %date.', array(
              '%date' => format_date(strtotime($node->{$start['field']}[0]['value']), 'custom', 'F, jS Y'),
            )),
          ));
      }
    }
  }
}

/**
 * Inserts or updates a course report record.
 *
 * @param object $entry
 *   The report entry to be saved into {course_report}, containing:
 *   - nid: Required. the node id.
 *   - uid: Required. the user id.
 *   - data: An array containing:
 *     - user: The serialized user object at the time of entry.
 *     - profile: The serialized user profile at the time of entry.
 *   - updated: Timestamp. The entry time.
 *
 * @todo Check for missing fields.
 */
function course_report_save($entry) {
  // No shenanigans.
  if (!$entry->nid > 0 || !$entry->uid > 0) {
    $message = t('Report not entered because entry must have nid and uid.');
    watchdog('course_report', $message, WATCHDOG_ERROR);
    drupal_set_message(check_plain($message), 'error');
    return FALSE;
  }

  // Load user so we can serialize it.
  $account = user_load($entry->uid);

  $entry->updated = time();

  $sql = "select * from {course_report} where nid = %d and uid = %d";
  $result = db_query($sql, $entry->nid, $entry->uid);
  $old = db_fetch_object($result);

  // Allow modules to alter course reports.
  drupal_alter('course_report', $entry, $account, $old);

  if ($entry->complete && empty($entry->date_completed)) {
    $entry->date_completed = time();
  }

  // Hello CE credit!
  if ($old) {
    drupal_write_record('course_report', $entry, array('nid', 'uid'));
  }
  else {
    drupal_write_record('course_report', $entry);
  }

  // Notify modules that a course report has been saved.
  module_invoke_all('course_report_saved', $entry, $account, $old);
}

/**
 * Implements hook_user().
 *
 * Delete the user's course records, fulfillments, and enrollments upon
 * deletion.
 */
function course_user($op, &$edit, &$account, $category = NULL) {
  if ($op == 'delete') {
    $sql = "delete from {course_report} where uid = %d";
    db_query($sql, $account->uid);
    $sql = "DELETE FROM {course_outline_fulfillment} WHERE uid = %d";
    db_query($sql, $account->uid);
    $sql = "delete from {course_enrolment} where uid = %d";
    db_query($sql, $account->uid);
  }
}

/**
 * Implements hook_views_bulk_operations_object_info().
 *
 * Expose information about the course report object to VBO.
 */
function course_views_bulk_operations_object_info() {
  return array(
    'course_report' => array(
      'type' => 'course_report',
      'base_table' => 'course_report',
      'load' => 'course_report_load',
      'title' => 'name',
    )
  );
}

/**
 * Load a course report entry, by report entry ID or node/user object.
 *
 * @return object
 *   An object representation of a course report.
 */
function course_report_load($mixed, $user = NULL) {
  if (is_object($mixed)) {
    return db_fetch_object(db_query('select cr.* from {course_report} cr
    where nid = %d and uid = %d', $mixed->nid, $user->uid));
  }
  elseif (is_numeric($user)) {
    return db_fetch_object(db_query('select cr.* from {course_report} cr
    where nid = %d and uid = %d', $mixed, $user));
  }
  else {
    return db_fetch_object(db_query('select cr.* from {course_report} cr
    where crid = %d', $mixed));
  }
}

/**
 * Implements hook_theme().
 */
function course_theme() {
  return array(
    'course_outline_overview_form' => array(
      'form' => NULL,
    ),
    'course_report' => array(
      'file' => 'includes/course.reports.inc',
      'arguments' => array(
        'nav' => NULL,
        'header' => NULL,
        'body' => NULL,
      ),
    ),
  );
}

/**
 * Delete a course requirement.
 *
 * @param array $mixed
 *   An array representing a course requirement (containing 'coid').
 */
function course_outline_delete_requirement($mixed) {
  if (is_object($mixed)) {
    $mixed = (array) $mixed;
  }
  $sql = "delete from {course_outline} where coid = %d";
  db_query($sql, $mixed['coid']);
  $sql = "delete from {course_outline_fulfillment} where coid = %d";
  db_query($sql, $mixed['coid']);
}

/**
 * Gets the course context.
 *
 * @todo support Context.
 */
function course_get_context() {
  return course_set_context();
}

/**
 * Sets a course context.
 *
 * @todo support Context.
 */
function course_set_context($node = NULL, $clear = FALSE) {
  static $stored_course_node;

  if ($clear) {
    $stored_course_node = NULL;
  }

  if (!empty($node)) {
    $stored_course_node = $node;
  }

  return (!empty($stored_course_node)) ? $stored_course_node : NULL;
}

/**
 * Get the course node automatically, or from optional query parameters.
 *
 * @param string $module
 *   The implementing course object provider module name.
 * @param string $object_type
 *   The course object key as defined by hook_course_handlers().
 * @param string $instance
 *   A key used internally by the implementing course object provider module,
 *   to identify an instance of *something* used by this course object type.
 * @param bool $no_set
 *   Do not set the context (active course), just return it.
 * @param bool $flush
 *   Flush the static cache. By default, course_determine_context will stop
 *   processing once a course is found, and continue to return it.
 *
 * @return mixed
 *   A course node or NULL if course context not found.
 */
function course_determine_context($module = NULL, $object_type = NULL, $instance = NULL, $no_set = FALSE, $flush = FALSE) {
  static $cache = NULL;

  if (!$context || $flush || $no_set) {
    // Determine the course node based on passed query parameters.
    $sql = "select nid from {course_outline}
      where instance = '%s'
      and module = '%s'
      and object_type = '%s'";

    $result = db_query($sql, $instance, $module, $object_type);
    $nids = array();
    while ($course_outline = db_fetch_object($result)) {
      $nids[] = $course_outline->nid;
    }

    if (count($nids) > 1) {
      if (in_array($_SESSION['course']['active'], $nids)) {
        // The active course in the session is one of the courses this object
        // belongs to.
        $context = node_load($_SESSION['course']['active']);
      }
      else {
        // No active course, or no match. We have to guess since we're accessing
        // this course material outside of the course.
        $context = node_load($nids[0]);
      }
    }
    elseif ($nids) {
      // We don't have an active session (or, the course in the active session
      // didn't contain this course object). So we just guess the first one.
      $context = node_load($nids[0]);
    }

    if ($no_set) {
      // Callee just wants context.
      return $context;
    }
    else {
      // Set the active course and static cache it.
      $_SESSION['course']['active'] = $context->nid;
      $cache = $context;
    }
  }

  return $cache;
}

/**
 * Implements hook_date_api_fields().
 *
 * Expose the course date columns to date API.
 */
function course_date_api_fields($field) {
  $values = array(
    'sql_type' => DATE_UNIX,
    'granularity' => array('year', 'month', 'day'),
  );

  switch ($field) {
    case 'course_report.date_completed':
    case 'course_report.updated':
    case 'course_enrolment.timestamp':
    case 'course_enrolment.enrol_end':
    case 'course_node.open':
    case 'course_node.close':
      return $values;
  }
}

/**
 * Implements hook_date_api_tables().
 */
function course_date_api_tables() {
  return array('course_report', 'course_enrolment', 'course_node');
}

/**
 * Implements hook_services_resources().
 */
function course_services_resources() {
  require_once("services/course_report_resource.inc");
  require_once("services/course_credit_resource.inc");

  $resources = array();

  $resources += _course_report_resource();
  $resources += _course_credit_resource();

  return $resources;
}

/**
 * Get all the options for a user type selection.
 */
function course_user_type_get_options() {
  $field_name = variable_get('course_user_types_field', '');
  $options = array();

  if (!empty($field_name)) {
    $options = content_allowed_values(content_fields($field_name));
  }

  $lines = explode("\n", variable_get('course_user_types', ''));
  $additional = array();
  foreach ($lines as $line) {
    $line = explode('|', $line);
    if ($line[0]) {
      $additional[$line[0]] = $line[1];
    }
  }

  return array_merge($options, $additional);
}

/**
 * Helper function for autocompletion of node titles.
 */
function course_object_autocomplete_node($types, $string) {
  $values = explode(',', $types);
  $placeholders = db_placeholders($values, 'varchar');
  $values[] = $string;
  $values[] = $string;
  $result = db_query_range(db_rewrite_sql("SELECT n.nid, n.title, u.name FROM {node} n
    INNER JOIN {users} u ON u.uid = n.uid
    WHERE n.type IN ($placeholders) AND (title LIKE '%%%s%%' OR n.nid = %d)"), $values, 0, 10);

  $matches = array();
  while ($node = db_fetch_object($result)) {
    $matches[$node->title . " [nid: $node->nid]"] = '<span class="autocomplete_title">' . check_plain($node->title) . '</span>';
  }

  drupal_json($matches);
}
